var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#API:-Quantum-objects-types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"General basis types. Specialized bases can be found in the section API: Quantum-systems.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Basis","category":"page"},{"location":"api/#QuantumInterface.Basis","page":"API","title":"QuantumInterface.Basis","text":"Abstract base class for all specialized bases.\n\nThe Basis class is meant to specify a basis of the Hilbert space of the studied system. Besides basis specific information all subclasses must implement a shape variable which indicates the dimension of the used Hilbert space. For a spin-1/2 Hilbert space this would be the vector [2]. A system composed of two spins would then have a shape vector [2 2].\n\nComposite systems can be defined with help of the CompositeBasis class.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"GenericBasis","category":"page"},{"location":"api/#QuantumInterface.GenericBasis","page":"API","title":"QuantumInterface.GenericBasis","text":"GenericBasis(N)\n\nA general purpose basis of dimension N.\n\nShould only be used rarely since it defeats the purpose of checking that the bases of state vectors and operators are correct for algebraic operations. The preferred way is to specify special bases for different systems.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"CompositeBasis","category":"page"},{"location":"api/#QuantumInterface.CompositeBasis","page":"API","title":"QuantumInterface.CompositeBasis","text":"CompositeBasis(b1, b2...)\n\nBasis for composite Hilbert spaces.\n\nStores the subbases in a vector and creates the shape vector directly from the shape vectors of these subbases. Instead of creating a CompositeBasis directly tensor(b1, b2...) or b1 ⊗ b2 ⊗ … can be used.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"States","category":"page"},{"location":"api/","page":"API","title":"API","text":"StateVector","category":"page"},{"location":"api/#QuantumInterface.StateVector","page":"API","title":"QuantumInterface.StateVector","text":"Abstract base class for Bra and Ket states.\n\nThe state vector class stores the coefficients of an abstract state in respect to a certain basis. These coefficients are stored in the data field and the basis is defined in the basis field.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Bra","category":"page"},{"location":"api/#QuantumOpticsBase.Bra","page":"API","title":"QuantumOpticsBase.Bra","text":"Bra(b::Basis[, data])\n\nBra state defined by coefficients in respect to the basis.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Ket","category":"page"},{"location":"api/#QuantumOpticsBase.Ket","page":"API","title":"QuantumOpticsBase.Ket","text":"Ket(b::Basis[, data])\n\nKet state defined by coefficients in respect to the given basis.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"General purpose QuantumOpticsBase. A few more specialized operators are implemented in API: Quantum-systems.","category":"page"},{"location":"api/","page":"API","title":"API","text":"AbstractOperator","category":"page"},{"location":"api/#QuantumInterface.AbstractOperator","page":"API","title":"QuantumInterface.AbstractOperator","text":"Abstract base class for all operators.\n\nAll deriving operator classes have to define the fields basis_l and basis_r defining the left and right side bases.\n\nFor fast time evolution also at least the function mul!(result::Ket,op::AbstractOperator,x::Ket,alpha,beta) should be implemented. Many other generic multiplication functions can be defined in terms of this function and are provided automatically.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"DataOperator","category":"page"},{"location":"api/#QuantumOpticsBase.DataOperator","page":"API","title":"QuantumOpticsBase.DataOperator","text":"Abstract type for operators with a data field.\n\nThis is an abstract type for operators that have a direct matrix representation stored in their .data field.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Operator","category":"page"},{"location":"api/#QuantumOpticsBase.Operator","page":"API","title":"QuantumOpticsBase.Operator","text":"Operator{BL,BR,T} <: DataOperator{BL,BR}\n\nOperator type that stores the representation of an operator on the Hilbert spaces given by BL and BR (e.g. a Matrix).\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"DenseOperator","category":"page"},{"location":"api/#QuantumOpticsBase.DenseOperator","page":"API","title":"QuantumOpticsBase.DenseOperator","text":"DenseOperator(b1[, b2, data])\n\nDense array implementation of Operator. Converts any given data to a dense Matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"SparseOperator","category":"page"},{"location":"api/#QuantumOpticsBase.SparseOperator","page":"API","title":"QuantumOpticsBase.SparseOperator","text":"SparseOperator(b1[, b2, data])\n\nSparse array implementation of Operator.\n\nThe matrix is stored as the julia built-in type SparseMatrixCSC in the data field.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"LazyTensor","category":"page"},{"location":"api/#QuantumOpticsBase.LazyTensor","page":"API","title":"QuantumOpticsBase.LazyTensor","text":"LazyTensor(b1[, b2], indices, operators[, factor=1])\n\nLazy implementation of a tensor product of operators.\n\nThe suboperators are stored in the operators field. The indices field specifies in which subsystem the corresponding operator lives. Note that these must be sorted. Additionally, a factor is stored in the factor field which allows for fast multiplication with numbers.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"LazySum","category":"page"},{"location":"api/#QuantumOpticsBase.LazySum","page":"API","title":"QuantumOpticsBase.LazySum","text":"LazySum([Tf,] [factors,] operators)\nLazySum([Tf,] basis_l, basis_r, [factors,] [operators])\nLazySum(::Tuple, x::LazySum)\n\nLazy evaluation of sums of operators.\n\nAll operators have to be given in respect to the same bases. The field factors accounts for an additional multiplicative factor for each operator stored in the operators field.\n\nThe factor type Tf can be specified to avoid having to infer it from the factors and operators themselves. All factors will be converted to type Tf.\n\nThe operators will be kept as is. It can be, for example, a Tuple or a Vector of operators. Using a Tuple is recommended for runtime performance of operator-state operations, such as simulating time evolution. A Vector can reduce compile-time overhead when doing arithmetic on LazySums, such as summing many LazySums together.\n\nTo convert a vector-based LazySum x to use a tuple for operator storage, use LazySum(::Tuple, x). \n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"LazyProduct","category":"page"},{"location":"api/#QuantumOpticsBase.LazyProduct","page":"API","title":"QuantumOpticsBase.LazyProduct","text":"LazyProduct(operators[, factor=1])\nLazyProduct(op1, op2...)\n\nLazy evaluation of products of operators.\n\nThe factors of the product are stored in the operators field. Additionally a complex factor is stored in the factor field which allows for fast multiplication with numbers.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Time-dependent operators.","category":"page"},{"location":"api/","page":"API","title":"API","text":"AbstractTimeDependentOperator","category":"page"},{"location":"api/#QuantumOpticsBase.AbstractTimeDependentOperator","page":"API","title":"QuantumOpticsBase.AbstractTimeDependentOperator","text":"AbstractTimeDependentOperator{BL,BR} <: AbstractOperator{BL,BR}\n\nAbstract type providing a time-dependent operator interface. Time-dependent operators have internal \"clocks\" that can be addressed with set_time! and current_time. A shorthand op(t), equivalent to set_time!(copy(op), t), is available for brevity.\n\nA time-dependent operator is always concrete-valued according to the current time of its internal clock.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"TimeDependentSum","category":"page"},{"location":"api/#QuantumOpticsBase.TimeDependentSum","page":"API","title":"QuantumOpticsBase.TimeDependentSum","text":"TimeDependentSum(lazysum, coeffs, init_time)\nTimeDependentSum(::Type{Tf}, basis_l, basis_r; init_time=0.0)\nTimeDependentSum([::Type{Tf},] [basis_l,] [basis_r,] coeffs, operators; init_time=0.0)\nTimeDependentSum([::Type{Tf},] coeff1=>op1, coeff2=>op2, ...; init_time=0.0)\nTimeDependentSum(::Tuple, op::TimeDependentSum)\n\nLazy sum of operators with time-dependent coefficients. Wraps a LazySum lazysum, adding a current_time (or operator \"clock\") and a means of specifying time coefficients as functions of time (or numbers).\n\nThe coefficient type Tf may be specified explicitly. Time-dependent coefficients will be converted to this type on evaluation.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Super operators:","category":"page"},{"location":"api/","page":"API","title":"API","text":"SuperOperator","category":"page"},{"location":"api/#QuantumOpticsBase.SuperOperator","page":"API","title":"QuantumOpticsBase.SuperOperator","text":"SuperOperator <: AbstractSuperOperator\n\nSuperOperator stored as representation, e.g. as a Matrix.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"DenseSuperOperator","category":"page"},{"location":"api/#QuantumOpticsBase.DenseSuperOperator","page":"API","title":"QuantumOpticsBase.DenseSuperOperator","text":"DenseSuperOperator(b1[, b2, data])\nDenseSuperOperator([T=ComplexF64,], b1[, b2])\n\nSuperOperator stored as dense matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"SparseSuperOperator","category":"page"},{"location":"api/#QuantumOpticsBase.SparseSuperOperator","page":"API","title":"QuantumOpticsBase.SparseSuperOperator","text":"SparseSuperOperator(b1[, b2, data])\nSparseSuperOperator([T=ComplexF64,], b1[, b2])\n\nSuperOperator stored as sparse matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Quantum-objects-functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Functions to generate general states, operators and super-operators","category":"page"},{"location":"api/","page":"API","title":"API","text":"basisstate","category":"page"},{"location":"api/#QuantumOpticsBase.basisstate","page":"API","title":"QuantumOpticsBase.basisstate","text":"basisstate([T=ComplexF64, ]b, index)\n\nBasis vector specified by index as ket state.\n\nFor a composite system index can be a vector which then creates a tensor product state i_1i_2i_n of the corresponding basis states.\n\n\n\n\n\nbasisstate([T=ComplexF64,] b::ManyBodyBasis, occupation::Vector)\n\nReturn a ket state where the system is in the state specified by the given occupation numbers.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"sparsebasisstate","category":"page"},{"location":"api/#QuantumOpticsBase.sparsebasisstate","page":"API","title":"QuantumOpticsBase.sparsebasisstate","text":"sparsebasisstate([T=ComplexF64, ]b, index)\n\nSparse version of basisstate.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"identityoperator","category":"page"},{"location":"api/#QuantumInterface.identityoperator","page":"API","title":"QuantumInterface.identityoperator","text":"identityoperator(a::Basis[, b::Basis])\nidentityoperator(::Type{<:AbstractOperator}, a::Basis[, b::Basis])\nidentityoperator(::Type{<:Number}, a::Basis[, b::Basis])\nidentityoperator(::Type{<:AbstractOperator}, ::Type{<:Number}, a::Basis[, b::Basis])\n\nReturn an identityoperator in the given bases. One can optionally specify the container type which has to a subtype of AbstractOperator as well as the number type to be used in the identity matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"diagonaloperator","category":"page"},{"location":"api/#QuantumOpticsBase.diagonaloperator","page":"API","title":"QuantumOpticsBase.diagonaloperator","text":"diagonaloperator(b::Basis)\n\nCreate a diagonal operator of type SparseOperator.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"randoperator","category":"page"},{"location":"api/#QuantumOpticsBase.randoperator","page":"API","title":"QuantumOpticsBase.randoperator","text":"randoperator([T=ComplexF64,] b1[, b2])\n\nCalculate a random unnormalized dense operator.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"spre","category":"page"},{"location":"api/#QuantumOpticsBase.spre","page":"API","title":"QuantumOpticsBase.spre","text":"spre(op)\n\nCreate a super-operator equivalent for right side operator multiplication.\n\nFor operators A, B the relation\n\n    mathrmspre(A) B = A B\n\nholds. op can be a dense or a sparse operator.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"spost","category":"page"},{"location":"api/#QuantumOpticsBase.spost","page":"API","title":"QuantumOpticsBase.spost","text":"spost(op)\n\nCreate a super-operator equivalent for left side operator multiplication.\n\nFor operators A, B the relation\n\n    mathrmspost(A) B = B A\n\nholds. op can be a dense or a sparse operator.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"sprepost","category":"page"},{"location":"api/#QuantumOpticsBase.sprepost","page":"API","title":"QuantumOpticsBase.sprepost","text":"sprepost(op)\n\nCreate a super-operator equivalent for left and right side operator multiplication.\n\nFor operators A, B, C the relation\n\n    mathrmsprepost(A B) C = A C B\n\nholds. A ond B can be dense or a sparse operators.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"liouvillian","category":"page"},{"location":"api/#QuantumOpticsBase.liouvillian","page":"API","title":"QuantumOpticsBase.liouvillian","text":"liouvillian(H, J; rates, Jdagger)\n\nCreate a super-operator equivalent to the master equation so that dot ρ = S ρ.\n\nThe super-operator S is defined by\n\nS ρ = -fraciħ H ρ + sum_i J_i ρ J_i^ - frac12 J_i^ J_i ρ - frac12 ρ J_i^ J_i\n\nArguments\n\nH: Hamiltonian.\nJ: Vector containing the jump operators.\nrates: Vector or matrix specifying the coefficients for the jump operators.\nJdagger: Vector containing the hermitian conjugates of the jump operators. If they            are not given they are calculated automatically.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"As far as it makes sense the same functions are implemented for bases, states, operators and superQuantumOpticsBase.","category":"page"},{"location":"api/","page":"API","title":"API","text":"QuantumOpticsBase.samebases","category":"page"},{"location":"api/#QuantumInterface.samebases","page":"API","title":"QuantumInterface.samebases","text":"samebases(a, b)\n\nTest if two objects have the same bases.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"QuantumOpticsBase.check_samebases","category":"page"},{"location":"api/#QuantumInterface.check_samebases","page":"API","title":"QuantumInterface.check_samebases","text":"check_samebases(a, b)\n\nThrow an IncompatibleBases error if the objects don't have the same bases.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"@samebases","category":"page"},{"location":"api/#QuantumInterface.@samebases","page":"API","title":"QuantumInterface.@samebases","text":"@samebases\n\nMacro to skip checks for same bases. Useful for *, expect and similar functions.\n\n\n\n\n\n","category":"macro"},{"location":"api/","page":"API","title":"API","text":"QuantumOpticsBase.multiplicable","category":"page"},{"location":"api/#QuantumInterface.multiplicable","page":"API","title":"QuantumInterface.multiplicable","text":"multiplicable(a, b)\n\nCheck if two objects are multiplicable.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"QuantumOpticsBase.check_multiplicable","category":"page"},{"location":"api/#QuantumInterface.check_multiplicable","page":"API","title":"QuantumInterface.check_multiplicable","text":"check_multiplicable(a, b)\n\nThrow an IncompatibleBases error if the objects are not multiplicable.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"QuantumOpticsBase.basis","category":"page"},{"location":"api/#QuantumInterface.basis","page":"API","title":"QuantumInterface.basis","text":"basis(a)\n\nReturn the basis of an object.\n\nIf it's ambiguous, e.g. if an operator has a different left and right basis, an IncompatibleBases error is thrown.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"dagger","category":"page"},{"location":"api/#QuantumInterface.dagger","page":"API","title":"QuantumInterface.dagger","text":"dagger(x)\n\nHermitian conjugate.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"tensor","category":"page"},{"location":"api/#QuantumInterface.tensor","page":"API","title":"QuantumInterface.tensor","text":"tensor(x, y, z...)\n\nTensor product of the given objects. Alternatively, the unicode symbol ⊗ (\\otimes) can be used.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"projector(a::Ket, b::Bra)\nprojector(a::Ket)\nprojector(a::Bra)","category":"page"},{"location":"api/#QuantumInterface.projector-Tuple{Ket, Bra}","page":"API","title":"QuantumInterface.projector","text":"projector(a::Ket, b::Bra)\n\nProjection operator ab.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumInterface.projector-Tuple{Ket}","page":"API","title":"QuantumInterface.projector","text":"projector(a::Ket)\n\nProjection operator aa.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumInterface.projector-Tuple{Bra}","page":"API","title":"QuantumInterface.projector","text":"projector(a::Bra)\n\nProjection operator aa.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"sparseprojector","category":"page"},{"location":"api/#QuantumOpticsBase.sparseprojector","page":"API","title":"QuantumOpticsBase.sparseprojector","text":"sparseprojector([T,] b1, b2)\n\nSparse version of projector.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"dm","category":"page"},{"location":"api/#QuantumInterface.dm","page":"API","title":"QuantumInterface.dm","text":"dm(a::StateVector)\n\nCreate density matrix aa. Same as projector(a).\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"QuantumOpticsBase.norm(x::StateVector)","category":"page"},{"location":"api/#LinearAlgebra.norm-Tuple{StateVector}","page":"API","title":"LinearAlgebra.norm","text":"norm(x::StateVector)\n\nNorm of the given bra or ket state.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"tr","category":"page"},{"location":"api/#LinearAlgebra.tr","page":"API","title":"LinearAlgebra.tr","text":"tr(x::AbstractOperator)\n\nTrace of the given operator.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"ptrace","category":"page"},{"location":"api/#QuantumInterface.ptrace","page":"API","title":"QuantumInterface.ptrace","text":"ptrace(a, indices)\n\nPartial trace of the given basis, state or operator.\n\nThe indices argument, which can be a single integer or a vector of integers, specifies which subsystems are traced out. The number of indices has to be smaller than the number of subsystems, i.e. it is not allowed to perform a full trace.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"normalize(x::StateVector)\nnormalize(op::AbstractOperator)","category":"page"},{"location":"api/#LinearAlgebra.normalize-Tuple{StateVector}","page":"API","title":"LinearAlgebra.normalize","text":"normalize(x::StateVector)\n\nReturn the normalized state so that norm(x) is one.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.normalize-Tuple{AbstractOperator}","page":"API","title":"LinearAlgebra.normalize","text":"normalize(op)\n\nReturn the normalized operator so that its tr(op) is one.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"normalize!(x::StateVector)\nnormalize!(op::AbstractOperator)","category":"page"},{"location":"api/#LinearAlgebra.normalize!-Tuple{StateVector}","page":"API","title":"LinearAlgebra.normalize!","text":"normalize!(x::StateVector)\n\nIn-place normalization of the given bra or ket so that norm(x) is one.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.normalize!-Tuple{AbstractOperator}","page":"API","title":"LinearAlgebra.normalize!","text":"normalize!(op)\n\nIn-place normalization of the given operator so that its tr(x) is one.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"expect","category":"page"},{"location":"api/#QuantumInterface.expect","page":"API","title":"QuantumInterface.expect","text":"expect(op, state)\n\nExpectation value of the given operator op for the specified state.\n\nstate can either be a (density) operator or a ket.\n\n\n\n\n\nexpect(index, op, state)\n\nIf an index is given, it assumes that op is defined in the subsystem specified by this number.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"variance","category":"page"},{"location":"api/#QuantumInterface.variance","page":"API","title":"QuantumInterface.variance","text":"variance(op, state)\n\nVariance of the given operator op for the specified state.\n\nstate can either be a (density) operator or a ket.\n\n\n\n\n\nvariance(index, op, state)\n\nIf an index is given, it assumes that op is defined in the subsystem specified by this number\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"embed","category":"page"},{"location":"api/#QuantumInterface.embed","page":"API","title":"QuantumInterface.embed","text":"embed(basis1[, basis2], indices::Vector, op::AbstractOperator)\n\nEmbed operator acting on a joint Hilbert space where missing indices are filled up with identity operators.\n\n\n\n\n\nembed(basis_l::SumBasis, basis_r::SumBasis,\n           index::Integer, operator)\n\nEmbed an operator defined on a single subspace specified by the index into a SumBasis.\n\n\n\n\n\nembed(basis_l::SumBasis, basis_r::SumBasis,\n            indices, operator)\n\nEmbed an operator defined on multiple subspaces specified by the indices into a SumBasis.\n\n\n\n\n\nembed(basis_l::SumBasis, basis_r::SumBasis,\n           indices, operators)\n\nEmbed a list of operators on subspaces specified by the indices into a SumBasis.\n\n\n\n\n\nembed(basis1[, basis2], operators::Dict)\n\noperators is a dictionary Dict{Vector{Int}, AbstractOperator}. The integer vector specifies in which subsystems the corresponding operator is defined.\n\n\n\n\n\nembed(basis1[, basis2], indices::Vector, operators::Vector)\n\nTensor product of operators where missing indices are filled up with identity operators.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"permutesystems","category":"page"},{"location":"api/#QuantumInterface.permutesystems","page":"API","title":"QuantumInterface.permutesystems","text":"permutesystems(a, perm)\n\nChange the ordering of the subsystems of the given object.\n\nFor a permutation vector [2,1,3] and a given object with basis [b1, b2, b3] this function results in [b2, b1, b3].\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"exp(op::AbstractOperator)","category":"page"},{"location":"api/#Base.exp-Tuple{AbstractOperator}","page":"API","title":"Base.exp","text":"exp(op::AbstractOperator)\n\nOperator exponential.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"Conversion of operators","category":"page"},{"location":"api/","page":"API","title":"API","text":"dense","category":"page"},{"location":"api/#QuantumOpticsBase.dense","page":"API","title":"QuantumOpticsBase.dense","text":"dense(op::AbstractOperator)\n\nConvert an arbitrary Operator into a DenseOperator.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"sparse(::AbstractOperator)","category":"page"},{"location":"api/#SparseArrays.sparse-Tuple{AbstractOperator}","page":"API","title":"SparseArrays.sparse","text":"sparse(op::AbstractOperator)\n\nConvert an arbitrary operator into a SparseOperator.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"Time-dependent operators.","category":"page"},{"location":"api/","page":"API","title":"API","text":"current_time","category":"page"},{"location":"api/#QuantumOpticsBase.current_time","page":"API","title":"QuantumOpticsBase.current_time","text":"current_time(op::AbstractOperator)\n\nReturns the current time of the operator op. If op is not time-dependent, this throws an ArgumentError.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"set_time!","category":"page"},{"location":"api/#QuantumOpticsBase.set_time!","page":"API","title":"QuantumOpticsBase.set_time!","text":"set_time!(o::AbstractOperator, t::Number)\n\nSets the clock of an operator (see AbstractTimeDependentOperator). If o contains other operators (e.g. in case o is a LazyOperator), recursively calls set_time! on those.\n\nThis does nothing in case o is not time-dependent.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"time_shift","category":"page"},{"location":"api/#QuantumOpticsBase.time_shift","page":"API","title":"QuantumOpticsBase.time_shift","text":"time_shift(op::TimeDependentSum, t0)\n\nShift (translate) a TimeDependentSum op forward in time (delaying its action) by t0 units, so that the coefficient functions of time f(t) become f(t-t0). Return a new TimeDependentSum.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"time_stretch","category":"page"},{"location":"api/#QuantumOpticsBase.time_stretch","page":"API","title":"QuantumOpticsBase.time_stretch","text":"time_stretch(op::TimeDependentSum, Sfactor)\n\nStretch (in time) a TimeDependentSum op by a factor of Sfactor (making it 'longer'), so that the coefficient functions of time f(t) become f(t/Sfactor). Return a new TimeDependentSum.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"time_restrict","category":"page"},{"location":"api/#QuantumOpticsBase.time_restrict","page":"API","title":"QuantumOpticsBase.time_restrict","text":"time_restrict(op::TimeDependentSum, t_from, t_to)\ntime_restrict(op::TimeDependentSum, t_to)\n\nRestrict a TimeDependentSum op to the time window t_from <= t < t_to, forcing it to be exactly zero outside that range of times. If t_from is not provided, it is assumed to be zero. Return a new TimeDependentSum.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Quantum-objects-exceptions","page":"API","title":"Exceptions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"QuantumOpticsBase.IncompatibleBases","category":"page"},{"location":"api/#QuantumInterface.IncompatibleBases","page":"API","title":"QuantumInterface.IncompatibleBases","text":"Exception that should be raised for an illegal algebraic operation.\n\n\n\n\n\n","category":"type"},{"location":"api/#API:-Quantum-systems","page":"API","title":"Quantum systems","text":"","category":"section"},{"location":"api/#API:-Fock","page":"API","title":"Fock","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"FockBasis","category":"page"},{"location":"api/#QuantumInterface.FockBasis","page":"API","title":"QuantumInterface.FockBasis","text":"FockBasis(N,offset=0)\n\nBasis for a Fock space where N specifies a cutoff, i.e. what the highest included fock state is. Similarly, the offset defines the lowest included fock state (default is 0). Note that the dimension of this basis is N+1-offset.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"number(::Type{T}, ::FockBasis) where T","category":"page"},{"location":"api/#QuantumOpticsBase.number-Union{Tuple{T}, Tuple{Type{T}, FockBasis}} where T","page":"API","title":"QuantumOpticsBase.number","text":"number([T=ComplexF64,] b::FockBasis)\n\nNumber operator for the specified Fock space with optional data type T.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"destroy(::Type{C}, ::FockBasis) where C","category":"page"},{"location":"api/#QuantumOpticsBase.destroy-Union{Tuple{C}, Tuple{Type{C}, FockBasis}} where C","page":"API","title":"QuantumOpticsBase.destroy","text":"destroy([T=ComplexF64,] b::FockBasis)\n\nAnnihilation operator for the specified Fock space with optional data type T.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"create(::Type{C}, ::FockBasis) where C","category":"page"},{"location":"api/#QuantumOpticsBase.create-Union{Tuple{C}, Tuple{Type{C}, FockBasis}} where C","page":"API","title":"QuantumOpticsBase.create","text":"create([T=ComplexF64,] b::FockBasis)\n\nCreation operator for the specified Fock space with optional data type T.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"displace","category":"page"},{"location":"api/#QuantumOpticsBase.displace","page":"API","title":"QuantumOpticsBase.displace","text":"displace([T=ComplexF64,] b::FockBasis, alpha)\n\nDisplacement operator D(α)=expleft(αhata^dagger-α^*hataright) for the specified Fock space with optional data type T, computed as the matrix exponential of finite-dimensional (truncated) creation and annihilation operators.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"displace_analytical","category":"page"},{"location":"api/#QuantumOpticsBase.displace_analytical","page":"API","title":"QuantumOpticsBase.displace_analytical","text":"displace_analytical(alpha::Number, n::Integer, m::Integer)\n\nGet a specific matrix element of the (analytical) displacement operator in the Fock basis: Dmn = ⟨n|D̂(α)|m⟩. The precision used for computation is based on the type of alpha. If alpha is a Float64, ComplexF64, or Int, the computation will be carried out at double precision.\n\n\n\n\n\ndisplace_analytical(b::FockBasis, alpha::Number)\ndisplace_analytical(::Type{T}, b::FockBasis, alpha::Number)\n\nGet the \"analytical\" displacement operator, whose matrix elements match (up to numerical imprecision) those of the exact infinite-dimensional displacement operator. This is different to the result of displace(..., alpha), which computes the matrix exponential exp(alpha * a' - conj(alpha) * a) using finite-dimensional (truncated) creation and annihilation operators a' and a.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"displace_analytical!","category":"page"},{"location":"api/#QuantumOpticsBase.displace_analytical!","page":"API","title":"QuantumOpticsBase.displace_analytical!","text":"displace_analytical!(op, alpha::Number)\n\nOverwrite, in place, the matrix elements of the FockBasis operator op, so that it is equal to displace_analytical(eltype(op), basis(op), alpha)\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"squeeze","category":"page"},{"location":"api/#QuantumOpticsBase.squeeze","page":"API","title":"QuantumOpticsBase.squeeze","text":"squeeze([T=ComplexF64,] b::FockBasis, z)\n\nSqueezing operator S(z)=expleft(fracz^*hata^2-zhata^dagger22right) for the specified Fock space with optional data type T, computed as the matrix exponential of finite-dimensional (truncated) creation and annihilation operators.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"fockstate","category":"page"},{"location":"api/#QuantumOpticsBase.fockstate","page":"API","title":"QuantumOpticsBase.fockstate","text":"fockstate([T=ComplexF64,] b::FockBasis, n)\n\nFock state n for the specified Fock space.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"coherentstate","category":"page"},{"location":"api/#QuantumOpticsBase.coherentstate","page":"API","title":"QuantumOpticsBase.coherentstate","text":"coherentstate([T=ComplexF64,] b::FockBasis, alpha)\n\nCoherent state α for the specified Fock space.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"coherentstate!","category":"page"},{"location":"api/#QuantumOpticsBase.coherentstate!","page":"API","title":"QuantumOpticsBase.coherentstate!","text":"coherentstate!(ket::Ket, b::FockBasis, alpha)\n\nInplace creation of coherent state α for the specified Fock space.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-N-level","page":"API","title":"N-level","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"NLevelBasis","category":"page"},{"location":"api/#QuantumInterface.NLevelBasis","page":"API","title":"QuantumInterface.NLevelBasis","text":"NLevelBasis(N)\n\nBasis for a system consisting of N states.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"transition(::Type{T}, ::NLevelBasis, ::Integer, ::Integer) where T","category":"page"},{"location":"api/#QuantumOpticsBase.transition-Union{Tuple{T}, Tuple{Type{T}, NLevelBasis, Integer, Integer}} where T","page":"API","title":"QuantumOpticsBase.transition","text":"transition([T=ComplexF64,] b::NLevelBasis, to::Integer, from::Integer)\n\nTransition operator mathrmtomathrmfrom.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"nlevelstate","category":"page"},{"location":"api/#QuantumOpticsBase.nlevelstate","page":"API","title":"QuantumOpticsBase.nlevelstate","text":"nlevelstate([T=ComplexF64,] b::NLevelBasis, n::Integer)\n\nState where the system is completely in the n-th level.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Spin","page":"API","title":"Spin","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"SpinBasis","category":"page"},{"location":"api/#QuantumInterface.SpinBasis","page":"API","title":"QuantumInterface.SpinBasis","text":"SpinBasis(n)\n\nBasis for spin-n particles.\n\nThe basis can be created for arbitrary spinnumbers by using a rational number, e.g. SpinBasis(3//2). The Pauli operators are defined for all possible spin numbers.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"sigmax","category":"page"},{"location":"api/#QuantumOpticsBase.sigmax","page":"API","title":"QuantumOpticsBase.sigmax","text":"sigmax([T=ComplexF64,] b::SpinBasis)\n\nPauli σ_x operator for the given Spin basis.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"sigmay","category":"page"},{"location":"api/#QuantumOpticsBase.sigmay","page":"API","title":"QuantumOpticsBase.sigmay","text":"sigmay([T=ComplexF64,] b::SpinBasis)\n\nPauli σ_y operator for the given Spin basis.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"sigmaz","category":"page"},{"location":"api/#QuantumOpticsBase.sigmaz","page":"API","title":"QuantumOpticsBase.sigmaz","text":"sigmaz([T=ComplexF64,] b::SpinBasis)\n\nPauli σ_z operator for the given Spin basis.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"sigmap","category":"page"},{"location":"api/#QuantumOpticsBase.sigmap","page":"API","title":"QuantumOpticsBase.sigmap","text":"sigmap([T=ComplexF64,] b::SpinBasis)\n\nRaising operator σ_+ for the given Spin basis.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"sigmam","category":"page"},{"location":"api/#QuantumOpticsBase.sigmam","page":"API","title":"QuantumOpticsBase.sigmam","text":"sigmam([T=ComplexF64,] b::SpinBasis)\n\nLowering operator σ_- for the given Spin basis.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"spinup","category":"page"},{"location":"api/#QuantumOpticsBase.spinup","page":"API","title":"QuantumOpticsBase.spinup","text":"spinup([T=ComplexF64,] b::SpinBasis)\n\nSpin up state for the given Spin basis.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"spindown","category":"page"},{"location":"api/#QuantumOpticsBase.spindown","page":"API","title":"QuantumOpticsBase.spindown","text":"spindown([T=ComplexF64], b::SpinBasis)\n\nSpin down state for the given Spin basis.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Particle","page":"API","title":"Particle","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"PositionBasis","category":"page"},{"location":"api/#QuantumOpticsBase.PositionBasis","page":"API","title":"QuantumOpticsBase.PositionBasis","text":"PositionBasis(xmin, xmax, Npoints)\nPositionBasis(b::MomentumBasis)\n\nBasis for a particle in real space.\n\nFor simplicity periodic boundaries are assumed which means that the rightmost point defined by xmax is not included in the basis but is defined to be the same as xmin.\n\nWhen a MomentumBasis is given as argument the exact values of x_min and x_max are due to the periodic boundary conditions more or less arbitrary and are chosen to be -pidp and pidp with dp=(p_max-p_min)N.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"MomentumBasis","category":"page"},{"location":"api/#QuantumOpticsBase.MomentumBasis","page":"API","title":"QuantumOpticsBase.MomentumBasis","text":"MomentumBasis(pmin, pmax, Npoints)\nMomentumBasis(b::PositionBasis)\n\nBasis for a particle in momentum space.\n\nFor simplicity periodic boundaries are assumed which means that pmax is not included in the basis but is defined to be the same as pmin.\n\nWhen a PositionBasis is given as argument the exact values of p_min and p_max are due to the periodic boundary conditions more or less arbitrary and are chosen to be -pidx and pidx with dx=(x_max-x_min)N.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"spacing","category":"page"},{"location":"api/#QuantumOpticsBase.spacing","page":"API","title":"QuantumOpticsBase.spacing","text":"spacing(b::PositionBasis)\n\nDifference between two adjacent points of the real space basis.\n\n\n\n\n\nspacing(b::MomentumBasis)\n\nMomentum difference between two adjacent points of the momentum basis.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"samplepoints","category":"page"},{"location":"api/#QuantumOpticsBase.samplepoints","page":"API","title":"QuantumOpticsBase.samplepoints","text":"samplepoints(b::PositionBasis)\n\nx values of the real space basis.\n\n\n\n\n\nsamplepoints(b::MomentumBasis)\n\np values of the momentum basis.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"position(::Type{T}, b::PositionBasis) where T\nposition(::Type{T}, b::MomentumBasis) where T","category":"page"},{"location":"api/#Base.position-Union{Tuple{T}, Tuple{Type{T}, PositionBasis}} where T","page":"API","title":"Base.position","text":"position([T=ComplexF64,] b::PositionBasis)\n\nPosition operator in real space.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.position-Union{Tuple{T}, Tuple{Type{T}, MomentumBasis}} where T","page":"API","title":"Base.position","text":"position([T=ComplexF64,] b:MomentumBasis)\n\nPosition operator in momentum space.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"momentum(::Type{T}, b::PositionBasis) where T\nmomentum(::Type{T}, b::MomentumBasis) where T","category":"page"},{"location":"api/#QuantumOpticsBase.momentum-Union{Tuple{T}, Tuple{Type{T}, PositionBasis}} where T","page":"API","title":"QuantumOpticsBase.momentum","text":"momentum([T=ComplexF64,] b::PositionBasis)\n\nMomentum operator in real space.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumOpticsBase.momentum-Union{Tuple{T}, Tuple{Type{T}, MomentumBasis}} where T","page":"API","title":"QuantumOpticsBase.momentum","text":"momentum([T=ComplexF64,] b:MomentumBasis)\n\nMomentum operator in momentum space.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"potentialoperator","category":"page"},{"location":"api/#QuantumOpticsBase.potentialoperator","page":"API","title":"QuantumOpticsBase.potentialoperator","text":"potentialoperator([T=Float64,] b::PositionBasis, V(x))\n\nOperator representing a potential V(x) in real space.\n\n\n\n\n\npotentialoperator([T=ComplexF64,] b::MomentumBasis, V(x))\n\nOperator representing a potential V(x) in momentum space.\n\n\n\n\n\npotentialoperator([T=Float64,] b::CompositeBasis, V(x, y, z, ...))\n\nOperator representing a potential V in more than one dimension.\n\nArguments\n\nb: Composite basis consisting purely either of PositionBasis or   MomentumBasis. Note, that calling this with a composite basis in   momentum space might consume a large amount of memory.\nV: Function describing the potential. ATTENTION: The number of arguments   accepted by V must match the spatial dimension. Furthermore, the order   of the arguments has to match that of the order of the tensor product of   bases (e.g. if b=bx⊗by⊗bz, then V(x,y,z)).\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"gaussianstate","category":"page"},{"location":"api/#QuantumOpticsBase.gaussianstate","page":"API","title":"QuantumOpticsBase.gaussianstate","text":"gaussianstate([T=ComplexF64,] b::PositionBasis, x0, p0, sigma)\ngaussianstate([T=ComplexF64,] b::MomentumBasis, x0, p0, sigma)\n\nCreate a Gaussian state around x0 andp0 with width sigma.\n\nIn real space the gaussian state is defined as\n\nPsi(x) = frac1pi^14sqrtsigma\n            e^i p_0 (x-fracx_02) - frac(x-x_0)^22 sigma^2\n\nand is connected to the momentum space definition\n\nPsi(p) = fracsqrtsigmapi^14\n            e^-i x_0 (p-fracp_02) - frac12(p-p_0)^2 sigma^2\n\nvia a Fourier-transformation\n\nPsi(p) = frac1sqrt2pi\n            int_-infty^infty e^-ipxPsi(x) mathrmdx\n\nThe state has the properties\n\np = p_0\nx = x_0\nmathrmVar(x) = fracσ^22\nmathrmVar(p) = frac12 σ^2\n\nDue to the numerically necessary discretization additional scaling factors sqrtΔx and sqrtΔp are used so that langle x_iΨrangle = sqrtΔ x Ψ(x_i) and langle p_iΨrangle = sqrtΔ p Ψ(p_i) so that the resulting Ket state is normalized.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"QuantumOpticsBase.FFTOperator","category":"page"},{"location":"api/#QuantumOpticsBase.FFTOperator","page":"API","title":"QuantumOpticsBase.FFTOperator","text":"FFTOperator\n\nAbstract type for all implementations of FFT operators.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"QuantumOpticsBase.FFTOperators","category":"page"},{"location":"api/#QuantumOpticsBase.FFTOperators","page":"API","title":"QuantumOpticsBase.FFTOperators","text":"FFTOperators\n\nOperator performing a fast fourier transformation when multiplied with a state that is a Ket or an Operator.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"QuantumOpticsBase.FFTKets","category":"page"},{"location":"api/#QuantumOpticsBase.FFTKets","page":"API","title":"QuantumOpticsBase.FFTKets","text":"FFTKets\n\nOperator that can only perform fast fourier transformations on Kets. This is much more memory efficient when only working with Kets.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"transform","category":"page"},{"location":"api/#QuantumOpticsBase.transform","page":"API","title":"QuantumOpticsBase.transform","text":"transform(b1::MomentumBasis, b2::PositionBasis)\ntransform(b1::PositionBasis, b2::MomentumBasis)\n\nTransformation operator between position basis and momentum basis.\n\n\n\n\n\ntransform(b1::CompositeBasis, b2::CompositeBasis)\n\nTransformation operator between two composite bases. Each of the bases has to contain bases of type PositionBasis and the other one a corresponding MomentumBasis.\n\n\n\n\n\ntransform([S=ComplexF64, ]b1::PositionBasis, b2::FockBasis; x0=1)\ntransform([S=ComplexF64, ]b1::FockBasis, b2::PositionBasis; x0=1)\n\nTransformation operator between position basis and fock basis.\n\nThe coefficients are connected via the relation\n\nψ(x_i) = sum_n=0^N x_in ψ_n\n\nwhere x_in is the value of the n-th eigenstate of a particle in a harmonic trap potential at position x, i.e.:\n\nx_in = π^-frac14 frace^-frac12left(fracxx_0right)^2sqrtx_0\n            frac1sqrt2^n n H_nleft(fracxx_0right)\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Subspace-bases","page":"API","title":"Subspace bases","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"SubspaceBasis","category":"page"},{"location":"api/#QuantumOpticsBase.SubspaceBasis","page":"API","title":"QuantumOpticsBase.SubspaceBasis","text":"SubspaceBasis(basisstates)\n\nA basis describing a subspace embedded a higher dimensional Hilbert space.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"QuantumOpticsBase.orthonormalize","category":"page"},{"location":"api/#QuantumOpticsBase.orthonormalize","page":"API","title":"QuantumOpticsBase.orthonormalize","text":"orthonormalize(b::SubspaceBasis)\n\nOrthonormalize the basis states of the given SubspaceBasis\n\nA modified Gram-Schmidt process is used.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"projector(::Type{T}, b1::SubspaceBasis, b2::SubspaceBasis) where T","category":"page"},{"location":"api/#QuantumInterface.projector-Union{Tuple{T}, Tuple{Type{T}, SubspaceBasis, SubspaceBasis}} where T","page":"API","title":"QuantumInterface.projector","text":"projector([T,] b1, b2)\n\nProjection operator between subspaces and superspaces or between two subspaces.\n\n\n\n\n\n","category":"method"},{"location":"api/#API:-Many-body","page":"API","title":"Many-body","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ManyBodyBasis","category":"page"},{"location":"api/#QuantumOpticsBase.ManyBodyBasis","page":"API","title":"QuantumOpticsBase.ManyBodyBasis","text":"ManyBodyBasis(b, occupations)\n\nBasis for a many body system.\n\nThe basis has to know the associated one-body basis b and which occupation states should be included. The occupations_hash is used to speed up checking if two many-body bases are equal.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"fermionstates","category":"page"},{"location":"api/#QuantumOpticsBase.fermionstates","page":"API","title":"QuantumOpticsBase.fermionstates","text":"fermionstates(Nmodes, Nparticles)\nfermionstates(b, Nparticles)\n\nGenerate all fermionic occupation states for N-particles in M-modes. Nparticles can be a vector to define a Hilbert space with variable particle number.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"bosonstates","category":"page"},{"location":"api/#QuantumOpticsBase.bosonstates","page":"API","title":"QuantumOpticsBase.bosonstates","text":"bosonstates(Nmodes, Nparticles)\nbosonstates(b, Nparticles)\n\nGenerate all bosonic occupation states for N-particles in M-modes. Nparticles can be a vector to define a Hilbert space with variable particle number.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"number(::Type{T}, ::ManyBodyBasis, index) where T\nnumber(::Type{T}, ::ManyBodyBasis) where T","category":"page"},{"location":"api/#QuantumOpticsBase.number-Union{Tuple{T}, Tuple{Type{T}, ManyBodyBasis, Any}} where T","page":"API","title":"QuantumOpticsBase.number","text":"number([T=ComplexF64,] b::ManyBodyBasis, index)\n\nParticle number operator for the i-th mode of the many-body basis b.\n\n\n\n\n\n","category":"method"},{"location":"api/#QuantumOpticsBase.number-Union{Tuple{T}, Tuple{Type{T}, ManyBodyBasis}} where T","page":"API","title":"QuantumOpticsBase.number","text":"number([T=ComplexF64,] b::ManyBodyBasis)\n\nTotal particle number operator.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"destroy(::Type{T}, ::ManyBodyBasis, index) where T","category":"page"},{"location":"api/#QuantumOpticsBase.destroy-Union{Tuple{T}, Tuple{Type{T}, ManyBodyBasis, Any}} where T","page":"API","title":"QuantumOpticsBase.destroy","text":"destroy([T=ComplexF64,] b::ManyBodyBasis, index)\n\nAnnihilation operator for the i-th mode of the many-body basis b.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"create(::Type{T}, ::ManyBodyBasis, index) where T","category":"page"},{"location":"api/#QuantumOpticsBase.create-Union{Tuple{T}, Tuple{Type{T}, ManyBodyBasis, Any}} where T","page":"API","title":"QuantumOpticsBase.create","text":"create([T=ComplexF64,] b::ManyBodyBasis, index)\n\nCreation operator for the i-th mode of the many-body basis b.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"transition(::Type{T}, ::ManyBodyBasis, i, j) where T","category":"page"},{"location":"api/#QuantumOpticsBase.transition-Union{Tuple{T}, Tuple{Type{T}, ManyBodyBasis, Any, Any}} where T","page":"API","title":"QuantumOpticsBase.transition","text":"transition([T=ComplexF64,] b::ManyBodyBasis, to, from)\n\nOperator mathrmtomathrmfrom transferring particles between modes.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"manybodyoperator","category":"page"},{"location":"api/#QuantumOpticsBase.manybodyoperator","page":"API","title":"QuantumOpticsBase.manybodyoperator","text":"manybodyoperator(b::ManyBodyBasis, op)\n\nCreate the many-body operator from the given one-body operator op.\n\nThe given operator can either be a one-body operator or a two-body interaction. Higher order interactions are at the moment not implemented.\n\nThe mathematical formalism for the one-body case is described by\n\nX = sum_ij a_i^ a_j u_i x  u_j\n\nand for the interaction case by\n\nX = sum_ijkl a_i^ a_j^ a_k a_l u_iu_j x u_ku_l\n\nwhere X is the N-particle operator, x is the one-body operator and u are the one-body states associated to the different modes of the N-particle basis.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"onebodyexpect","category":"page"},{"location":"api/#QuantumOpticsBase.onebodyexpect","page":"API","title":"QuantumOpticsBase.onebodyexpect","text":"onebodyexpect(op, state)\n\nExpectation value of the one-body operator op in respect to the many-body state.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Direct-sum","page":"API","title":"Direct sum","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"SumBasis","category":"page"},{"location":"api/#QuantumInterface.SumBasis","page":"API","title":"QuantumInterface.SumBasis","text":"SumBasis(b1, b2...)\n\nSimilar to CompositeBasis but for the directsum (⊕)\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"directsum","category":"page"},{"location":"api/#QuantumInterface.directsum","page":"API","title":"QuantumInterface.directsum","text":"directsum(x::Ket, y::Ket)\n\nConstruct a spinor via the directsum of two Kets. The result is a Ket with data given by [x.data;y.data] and its basis given by the corresponding SumBasis. NOTE: The resulting state is not normalized!\n\n\n\n\n\ndirectsum(x::DataOperator, y::DataOperator)\n\nCompute the direct sum of two operators. The result is an operator on the corresponding SumBasis.\n\n\n\n\n\ndirectsum(b1::Basis, b2::Basis)\n\nConstruct the SumBasis out of two sub-bases.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"LazyDirectSum","category":"page"},{"location":"api/#QuantumOpticsBase.LazyDirectSum","page":"API","title":"QuantumOpticsBase.LazyDirectSum","text":"LazyDirectSum <: AbstractOperator\n\nLazy implementation of directsum\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"getblock","category":"page"},{"location":"api/#QuantumOpticsBase.getblock","page":"API","title":"QuantumOpticsBase.getblock","text":"getblock(x::Ket{<:SumBasis}, i)\n\nFor a Ket defined on a SumBasis, get the state as it is defined on the ith sub-basis.\n\n\n\n\n\ngetblock(op::Operator{<:SumBasis,<:SumBasis}, i, j)\n\nGet the sub-basis operator corresponding to the block (i,j) of op.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"setblock!","category":"page"},{"location":"api/#QuantumOpticsBase.setblock!","page":"API","title":"QuantumOpticsBase.setblock!","text":"setblock!(x::Ket{<:SumBasis}, val::Ket, i)\n\nSet the data of x on the ith sub-basis equal to the data of val.\n\n\n\n\n\nsetblock!(op::DataOperator{<:SumBasis,<:SumBasis}, val::DataOperator, i, j)\n\nSet the data of op corresponding to the block (i,j) equal to the data of val.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Metrics","page":"API","title":"Metrics","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"tracenorm","category":"page"},{"location":"api/#QuantumOpticsBase.tracenorm","page":"API","title":"QuantumOpticsBase.tracenorm","text":"tracenorm(rho)\n\nTrace norm of rho.\n\nIt is defined as\n\nT(ρ) = Trsqrtρ^ ρ\n\nDepending if rho is hermitian either tracenorm_h or tracenorm_nh is called.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"tracenorm_h","category":"page"},{"location":"api/#QuantumOpticsBase.tracenorm_h","page":"API","title":"QuantumOpticsBase.tracenorm_h","text":"tracenorm_h(rho)\n\nTrace norm of rho.\n\nIt uses the identity\n\nT(ρ) = Trsqrtρ^ ρ = sum_i λ_i\n\nwhere λ_i are the eigenvalues of rho.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"tracenorm_nh","category":"page"},{"location":"api/#QuantumOpticsBase.tracenorm_nh","page":"API","title":"QuantumOpticsBase.tracenorm_nh","text":"tracenorm_nh(rho)\n\nTrace norm of rho.\n\nNote that in this case rho doesn't have to be represented by a square matrix (i.e. it can have different left-hand and right-hand bases).\n\nIt uses the identity\n\n    T(ρ) = Trsqrtρ^ ρ = sum_i σ_i\n\nwhere σ_i are the singular values of rho.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"tracedistance","category":"page"},{"location":"api/#QuantumOpticsBase.tracedistance","page":"API","title":"QuantumOpticsBase.tracedistance","text":"tracedistance(rho, sigma)\n\nTrace distance between rho and sigma.\n\nIt is defined as\n\nT(ρσ) = frac12 Trsqrt(ρ - σ)^ (ρ - σ)\n\nIt calls tracenorm which in turn either uses tracenorm_h or tracenorm_nh depending if ρ-σ is hermitian or not.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"tracedistance_h","category":"page"},{"location":"api/#QuantumOpticsBase.tracedistance_h","page":"API","title":"QuantumOpticsBase.tracedistance_h","text":"tracedistance_h(rho, sigma)\n\nTrace distance between rho and sigma.\n\nIt uses the identity\n\nT(ρσ) = frac12 Trsqrt(ρ - σ)^ (ρ - σ) = frac12 sum_i λ_i\n\nwhere λ_i are the eigenvalues of rho - sigma.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"tracedistance_nh","category":"page"},{"location":"api/#QuantumOpticsBase.tracedistance_nh","page":"API","title":"QuantumOpticsBase.tracedistance_nh","text":"tracedistance_nh(rho, sigma)\n\nTrace distance between rho and sigma.\n\nNote that in this case rho and sigma don't have to be represented by square matrices (i.e. they can have different left-hand and right-hand bases).\n\nIt uses the identity\n\n    T(ρσ) = frac12 Trsqrt(ρ - σ)^ (ρ - σ)\n         = frac12 sum_i σ_i\n\nwhere σ_i are the singular values of rho - sigma.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"entropy_vn","category":"page"},{"location":"api/#QuantumOpticsBase.entropy_vn","page":"API","title":"QuantumOpticsBase.entropy_vn","text":"entropy_vn(rho)\n\nVon Neumann entropy of a density matrix.\n\nThe Von Neumann entropy of a density operator is defined as\n\nS(ρ) = -Tr(ρ log(ρ)) = -sum_n λ_nlog(λ_n)\n\nwhere λ_n are the eigenvalues of the density matrix ρ, log is the natural logarithm and 0log(0)  0.\n\nArguments\n\nrho: Density operator of which to calculate Von Neumann entropy.\ntol=1e-15: Tolerance for rounding errors in the computed eigenvalues.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"entropy_renyi","category":"page"},{"location":"api/#QuantumOpticsBase.entropy_renyi","page":"API","title":"QuantumOpticsBase.entropy_renyi","text":"entropy_renyi(rho, α::Integer=2)\n\nRenyi α-entropy of a density matrix, where r α≥0, α≂̸1.\n\nThe Renyi α-entropy of a density operator is defined as\n\nS_α(ρ) = 1(1-α) log(Tr(ρ^α))\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"fidelity","category":"page"},{"location":"api/#QuantumOpticsBase.fidelity","page":"API","title":"QuantumOpticsBase.fidelity","text":"fidelity(rho, sigma)\n\nFidelity of two density operators.\n\nThe fidelity of two density operators ρ and σ is defined by\n\nF(ρ σ) = Trleft(sqrtsqrtρσsqrtρright)\n\nwhere sqrtρ=sum_nsqrtλ_nψψ.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"ptranspose","category":"page"},{"location":"api/#QuantumOpticsBase.ptranspose","page":"API","title":"QuantumOpticsBase.ptranspose","text":"ptranspose(rho, indices)\n\nPartial transpose of rho with respect to subsystem specified by indices. \n\nThe indices argument can be a single integer or a collection of integers.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"PPT","category":"page"},{"location":"api/#QuantumOpticsBase.PPT","page":"API","title":"QuantumOpticsBase.PPT","text":"PPT(rho, index)\n\nPeres-Horodecki criterion of partial transpose.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"negativity","category":"page"},{"location":"api/#QuantumOpticsBase.negativity","page":"API","title":"QuantumOpticsBase.negativity","text":"negativity(rho, index)\n\nNegativity of rho with respect to subsystem index.\n\nThe negativity of a density matrix ρ is defined as\n\nN(ρ) = fracρᵀ-12\n\nwhere ρᵀ is the partial transpose.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"logarithmic_negativity","category":"page"},{"location":"api/#QuantumOpticsBase.logarithmic_negativity","page":"API","title":"QuantumOpticsBase.logarithmic_negativity","text":"logarithmic_negativity(rho, index)\n\nThe logarithmic negativity of a density matrix ρ is defined as\n\nN(ρ) = log₂ρᵀ\n\nwhere ρᵀ is the partial transpose.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"entanglement_entropy","category":"page"},{"location":"api/#QuantumOpticsBase.entanglement_entropy","page":"API","title":"QuantumOpticsBase.entanglement_entropy","text":"entanglement_entropy(state, partition, [entropy_fun=entropy_vn])\n\nComputes the entanglement entropy of state between the list of sites partition and the rest of the system. The state must be defined in a composite basis.\n\nIf state isa AbstractOperator the operator-space entanglement entropy is computed, which has the property\n\nentanglement_entropy(dm(ket)) = 2 * entanglement_entropy(ket)\n\nBy default the computed entropy is the Von-Neumann entropy, but a different function can be provided (for example to compute the entanglement-renyi entropy).\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"avg_gate_fidelity","category":"page"},{"location":"api/#QuantumOpticsBase.avg_gate_fidelity","page":"API","title":"QuantumOpticsBase.avg_gate_fidelity","text":"avg_gate_fidelity(x, y)\n\nThe average gate fidelity between two superoperators x and y.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-State-definitions","page":"API","title":"State definitions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"randstate","category":"page"},{"location":"api/#QuantumOpticsBase.randstate","page":"API","title":"QuantumOpticsBase.randstate","text":"randstate([T=ComplexF64,] basis)\n\nCalculate a random normalized ket state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"thermalstate","category":"page"},{"location":"api/#QuantumOpticsBase.thermalstate","page":"API","title":"QuantumOpticsBase.thermalstate","text":"thermalstate(H,T)\n\nThermal state exp(-HT)Trexp(-HT).\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"coherentthermalstate","category":"page"},{"location":"api/#QuantumOpticsBase.coherentthermalstate","page":"API","title":"QuantumOpticsBase.coherentthermalstate","text":"coherentthermalstate([C=ComplexF64,] basis::FockBasis,H,T,alpha)\n\nCoherent thermal state D(α)exp(-HT)Trexp(-HT)D^(α).\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"phase_average","category":"page"},{"location":"api/#QuantumOpticsBase.phase_average","page":"API","title":"QuantumOpticsBase.phase_average","text":"phase_average(rho)\n\nReturns the phase-average of ρ containing only the diagonal elements.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"passive_state","category":"page"},{"location":"api/#QuantumOpticsBase.passive_state","page":"API","title":"QuantumOpticsBase.passive_state","text":"passive_state(rho,IncreasingEigenenergies=true)\n\nPassive state π of ρ. IncreasingEigenenergies=true means that higher indices correspond to higher energies.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Pauli","page":"API","title":"Pauli","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"PauliBasis","category":"page"},{"location":"api/#QuantumInterface.PauliBasis","page":"API","title":"QuantumInterface.PauliBasis","text":"PauliBasis(num_qubits::Int)\n\nBasis for an N-qubit space where num_qubits specifies the number of qubits. The dimension of the basis is 2²ᴺ.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"PauliTransferMatrix","category":"page"},{"location":"api/#QuantumOpticsBase.PauliTransferMatrix","page":"API","title":"QuantumOpticsBase.PauliTransferMatrix","text":"Base class for Pauli transfer matrix classes.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"DensePauliTransferMatrix","category":"page"},{"location":"api/#QuantumOpticsBase.DensePauliTransferMatrix","page":"API","title":"QuantumOpticsBase.DensePauliTransferMatrix","text":"DensePauliTransferMatrix(B1, B2, data)\n\nDensePauliTransferMatrix stored as a dense matrix.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"ChiMatrix","category":"page"},{"location":"api/#QuantumOpticsBase.ChiMatrix","page":"API","title":"QuantumOpticsBase.ChiMatrix","text":"Base class for χ (process) matrix classes.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"DenseChiMatrix","category":"page"},{"location":"api/#QuantumOpticsBase.DenseChiMatrix","page":"API","title":"QuantumOpticsBase.DenseChiMatrix","text":"DenseChiMatrix(b, b, data)\n\nDenseChiMatrix stored as a dense matrix.\n\n\n\n\n\n","category":"type"},{"location":"api/#API:-Printing","page":"API","title":"Printing","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"QuantumOpticsBase.set_printing","category":"page"},{"location":"api/#QuantumOpticsBase.set_printing","page":"API","title":"QuantumOpticsBase.set_printing","text":"QuantumOptics.set_printing(; standard_order, rounding_tol)\n\nSet options for REPL output.\n\nArguments\n\nstandard_order=false: For performance reasons, the order of the tensor   product is inverted, i.e. tensor(a, b)=kron(b, a). When changing this   to true, the output shown in the REPL will exhibit the correct order.\nrounding_tol=1e-17: Tolerance for floating point errors shown in the output.\n\n\n\n\n\n","category":"function"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The documentation found here is just the lightweight version of the full docs. It lists all types and functions as well as their API included in the QuantumOpticsBase.jl module. The full documentation of QuantumOptics.jl can be found here.","category":"page"}]
}
