<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · QuantumOpticsBase.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">QuantumOpticsBase.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#API:-Quantum-objects-types"><span>Types</span></a></li><li><a class="tocitem" href="#API:-Quantum-systems"><span>Quantum systems</span></a></li><li><a class="tocitem" href="#API:-Direct-sum"><span>Direct sum</span></a></li><li><a class="tocitem" href="#API:-Metrics"><span>Metrics</span></a></li><li><a class="tocitem" href="#API:-State-definitions"><span>State definitions</span></a></li><li><a class="tocitem" href="#API:-Pauli"><span>Pauli</span></a></li><li><a class="tocitem" href="#API:-Printing"><span>Printing</span></a></li><li><a class="tocitem" href="#API:-LazyTensor-functions"><span>LazyTensor functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="API:-Quantum-objects-types"><a class="docs-heading-anchor" href="#API:-Quantum-objects-types">Types</a><a id="API:-Quantum-objects-types-1"></a><a class="docs-heading-anchor-permalink" href="#API:-Quantum-objects-types" title="Permalink"></a></h2><ul><li>General basis types. Specialized bases can be found in the section <a href="#API:-Quantum-systems">API: Quantum-systems</a>.</li></ul><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.Basis" href="#QuantumInterface.Basis"><code>QuantumInterface.Basis</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract base class for all specialized bases.</p><p>The Basis class is meant to specify a basis of the Hilbert space of the studied system. Besides basis specific information all subclasses must implement a shape variable which indicates the dimension of the used Hilbert space. For a spin-1/2 Hilbert space this would be the vector <code>[2]</code>. A system composed of two spins would then have a shape vector <code>[2 2]</code>.</p><p>Composite systems can be defined with help of the <a href="#QuantumInterface.CompositeBasis"><code>CompositeBasis</code></a> class.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.GenericBasis" href="#QuantumInterface.GenericBasis"><code>QuantumInterface.GenericBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GenericBasis(N)</code></pre><p>A general purpose basis of dimension N.</p><p>Should only be used rarely since it defeats the purpose of checking that the bases of state vectors and operators are correct for algebraic operations. The preferred way is to specify special bases for different systems.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.CompositeBasis" href="#QuantumInterface.CompositeBasis"><code>QuantumInterface.CompositeBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CompositeBasis(b1, b2...)</code></pre><p>Basis for composite Hilbert spaces.</p><p>Stores the subbases in a vector and creates the shape vector directly from the shape vectors of these subbases. Instead of creating a CompositeBasis directly <code>tensor(b1, b2...)</code> or <code>b1 ⊗ b2 ⊗ …</code> can be used.</p></div></section></article><ul><li>States</li></ul><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.StateVector" href="#QuantumInterface.StateVector"><code>QuantumInterface.StateVector</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract base class for <code>Bra</code> and <code>Ket</code> states.</p><p>The state vector class stores the coefficients of an abstract state in respect to a certain basis. These coefficients are stored in the <code>data</code> field and the basis is defined in the <code>basis</code> field.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.Bra" href="#QuantumOpticsBase.Bra"><code>QuantumOpticsBase.Bra</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Bra(b::Basis[, data])</code></pre><p>Bra state defined by coefficients in respect to the basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/states.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.Ket" href="#QuantumOpticsBase.Ket"><code>QuantumOpticsBase.Ket</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Ket(b::Basis[, data])</code></pre><p>Ket state defined by coefficients in respect to the given basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/states.jl#L19-L23">source</a></section></article><ul><li>General purpose QuantumOpticsBase. A few more specialized operators are implemented in <a href="#API:-Quantum-systems">API: Quantum-systems</a>.</li></ul><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.AbstractOperator" href="#QuantumInterface.AbstractOperator"><code>QuantumInterface.AbstractOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract base class for all operators.</p><p>All deriving operator classes have to define the fields <code>basis_l</code> and <code>basis_r</code> defining the left and right side bases.</p><p>For fast time evolution also at least the function <code>mul!(result::Ket,op::AbstractOperator,x::Ket,alpha,beta)</code> should be implemented. Many other generic multiplication functions can be defined in terms of this function and are provided automatically.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.DataOperator" href="#QuantumOpticsBase.DataOperator"><code>QuantumOpticsBase.DataOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for operators with a data field.</p><p>This is an abstract type for operators that have a direct matrix representation stored in their <code>.data</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/operators.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.Operator" href="#QuantumOpticsBase.Operator"><code>QuantumOpticsBase.Operator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Operator{BL,BR,T} &lt;: DataOperator{BL,BR}</code></pre><p>Operator type that stores the representation of an operator on the Hilbert spaces given by <code>BL</code> and <code>BR</code> (e.g. a Matrix).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/operators_dense.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.DenseOperator" href="#QuantumOpticsBase.DenseOperator"><code>QuantumOpticsBase.DenseOperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">DenseOperator(b1[, b2, data])</code></pre><p>Dense array implementation of Operator. Converts any given data to a dense <code>Matrix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/operators_dense.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.SparseOperator" href="#QuantumOpticsBase.SparseOperator"><code>QuantumOpticsBase.SparseOperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SparseOperator(b1[, b2, data])</code></pre><p>Sparse array implementation of Operator.</p><p>The matrix is stored as the julia built-in type <code>SparseMatrixCSC</code> in the <code>data</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/operators_sparse.jl#L9-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.LazyTensor" href="#QuantumOpticsBase.LazyTensor"><code>QuantumOpticsBase.LazyTensor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LazyTensor(b1[, b2], indices, operators[, factor=1])</code></pre><p>Lazy implementation of a tensor product of operators.</p><p>The suboperators are stored in the <code>operators</code> field. The <code>indices</code> field specifies in which subsystem the corresponding operator lives. Note that these must be sorted. Additionally, a factor is stored in the <code>factor</code> field which allows for fast multiplication with numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/operators_lazytensor.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.LazySum" href="#QuantumOpticsBase.LazySum"><code>QuantumOpticsBase.LazySum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LazySum([Tf,] [factors,] operators)
LazySum([Tf,] basis_l, basis_r, [factors,] [operators])
LazySum(::Tuple, x::LazySum)</code></pre><p>Lazy evaluation of sums of operators.</p><p>All operators have to be given in respect to the same bases. The field <code>factors</code> accounts for an additional multiplicative factor for each operator stored in the <code>operators</code> field.</p><p>The factor type <code>Tf</code> can be specified to avoid having to infer it from the factors and operators themselves. All <code>factors</code> will be converted to type <code>Tf</code>.</p><p>The <code>operators</code> will be kept as is. It can be, for example, a <code>Tuple</code> or a <code>Vector</code> of operators. Using a <code>Tuple</code> is recommended for runtime performance of operator-state operations, such as simulating time evolution. A <code>Vector</code> can reduce compile-time overhead when doing arithmetic on <code>LazySum</code>s, such as summing many <code>LazySum</code>s together.</p><p>To convert a vector-based <code>LazySum</code> <code>x</code> to use a tuple for operator storage, use <code>LazySum(::Tuple, x)</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/operators_lazysum.jl#L17-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.LazyProduct" href="#QuantumOpticsBase.LazyProduct"><code>QuantumOpticsBase.LazyProduct</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LazyProduct(operators[, factor=1])
LazyProduct(op1, op2...)</code></pre><p>Lazy evaluation of products of operators.</p><p>The factors of the product are stored in the <code>operators</code> field. Additionally a complex factor is stored in the <code>factor</code> field which allows for fast multiplication with numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/operators_lazyproduct.jl#L3-L12">source</a></section></article><ul><li>Time-dependent operators.</li></ul><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.AbstractTimeDependentOperator" href="#QuantumOpticsBase.AbstractTimeDependentOperator"><code>QuantumOpticsBase.AbstractTimeDependentOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractTimeDependentOperator{BL,BR} &lt;: AbstractOperator{BL,BR}</code></pre><p>Abstract type providing a time-dependent operator interface. Time-dependent operators have internal &quot;clocks&quot; that can be addressed with <a href="#QuantumOpticsBase.set_time!"><code>set_time!</code></a> and <a href="#QuantumOpticsBase.current_time"><code>current_time</code></a>. A shorthand <code>op(t)</code>, equivalent to <code>set_time!(copy(op), t)</code>, is available for brevity.</p><p>A time-dependent operator is always concrete-valued according to the current time of its internal clock.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/time_dependent_operator.jl#L4-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.TimeDependentSum" href="#QuantumOpticsBase.TimeDependentSum"><code>QuantumOpticsBase.TimeDependentSum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TimeDependentSum(lazysum, coeffs, init_time)
TimeDependentSum(::Type{Tf}, basis_l, basis_r; init_time=0.0)
TimeDependentSum([::Type{Tf},] [basis_l,] [basis_r,] coeffs, operators; init_time=0.0)
TimeDependentSum([::Type{Tf},] coeff1=&gt;op1, coeff2=&gt;op2, ...; init_time=0.0)
TimeDependentSum(::Tuple, op::TimeDependentSum)</code></pre><p>Lazy sum of operators with time-dependent coefficients. Wraps a <a href="#QuantumOpticsBase.LazySum"><code>LazySum</code></a> <code>lazysum</code>, adding a <code>current_time</code> (or operator &quot;clock&quot;) and a means of specifying time coefficients as functions of time (or numbers).</p><p>The coefficient type <code>Tf</code> may be specified explicitly. Time-dependent coefficients will be converted to this type on evaluation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/time_dependent_operator.jl#L74-L87">source</a></section></article><ul><li>Super operators:</li></ul><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.SuperOperator" href="#QuantumOpticsBase.SuperOperator"><code>QuantumOpticsBase.SuperOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SuperOperator &lt;: AbstractSuperOperator</code></pre><p>SuperOperator stored as representation, e.g. as a Matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/superoperators.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.DenseSuperOperator" href="#QuantumOpticsBase.DenseSuperOperator"><code>QuantumOpticsBase.DenseSuperOperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">DenseSuperOperator(b1[, b2, data])
DenseSuperOperator([T=ComplexF64,], b1[, b2])</code></pre><p>SuperOperator stored as dense matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/superoperators.jl#L28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.SparseSuperOperator" href="#QuantumOpticsBase.SparseSuperOperator"><code>QuantumOpticsBase.SparseSuperOperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">SparseSuperOperator(b1[, b2, data])
SparseSuperOperator([T=ComplexF64,], b1[, b2])</code></pre><p>SuperOperator stored as sparse matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/superoperators.jl#L46-L51">source</a></section></article><h3 id="API:-Quantum-objects-functions"><a class="docs-heading-anchor" href="#API:-Quantum-objects-functions">Functions</a><a id="API:-Quantum-objects-functions-1"></a><a class="docs-heading-anchor-permalink" href="#API:-Quantum-objects-functions" title="Permalink"></a></h3><ul><li>Functions to generate general states, operators and super-operators</li></ul><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.basisstate" href="#QuantumOpticsBase.basisstate"><code>QuantumOpticsBase.basisstate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">basisstate([T=ComplexF64, ]b, index)</code></pre><p>Basis vector specified by <code>index</code> as ket state.</p><p>For a composite system <code>index</code> can be a vector which then creates a tensor product state <span>$|i_1⟩⊗|i_2⟩⊗…⊗|i_n⟩$</span> of the corresponding basis states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/states.jl#L120-L127">source</a></section><section><div><pre><code class="language-none">basisstate([T=ComplexF64,] b::ManyBodyBasis, occupation::Vector)</code></pre><p>Return a ket state where the system is in the state specified by the given occupation numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/manybody.jl#L78-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.sparsebasisstate" href="#QuantumOpticsBase.sparsebasisstate"><code>QuantumOpticsBase.sparsebasisstate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sparsebasisstate([T=ComplexF64, ]b, index)</code></pre><p>Sparse version of <a href="#QuantumOpticsBase.basisstate"><code>basisstate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/states.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.identityoperator" href="#QuantumInterface.identityoperator"><code>QuantumInterface.identityoperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">identityoperator(a::Basis[, b::Basis])
identityoperator(::Type{&lt;:AbstractOperator}, a::Basis[, b::Basis])
identityoperator(::Type{&lt;:Number}, a::Basis[, b::Basis])
identityoperator(::Type{&lt;:AbstractOperator}, ::Type{&lt;:Number}, a::Basis[, b::Basis])</code></pre><p>Return an identityoperator in the given bases. One can optionally specify the container type which has to a subtype of <a href="#QuantumInterface.AbstractOperator"><code>AbstractOperator</code></a> as well as the number type to be used in the identity matrix.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.diagonaloperator" href="#QuantumOpticsBase.diagonaloperator"><code>QuantumOpticsBase.diagonaloperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">diagonaloperator(b::Basis)</code></pre><p>Create a diagonal operator of type <a href="#QuantumOpticsBase.SparseOperator"><code>SparseOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/operators_sparse.jl#L91-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.randoperator" href="#QuantumOpticsBase.randoperator"><code>QuantumOpticsBase.randoperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randoperator([T=ComplexF64,] b1[, b2])</code></pre><p>Calculate a random unnormalized dense operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/state_definitions.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.spre" href="#QuantumOpticsBase.spre"><code>QuantumOpticsBase.spre</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">spre(op)</code></pre><p>Create a super-operator equivalent for right side operator multiplication.</p><p>For operators <span>$A$</span>, <span>$B$</span> the relation</p><p class="math-container">\[    \mathrm{spre}(A) B = A B\]</p><p>holds. <code>op</code> can be a dense or a sparse operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/superoperators.jl#L114-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.spost" href="#QuantumOpticsBase.spost"><code>QuantumOpticsBase.spost</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">spost(op)</code></pre><p>Create a super-operator equivalent for left side operator multiplication.</p><p>For operators <span>$A$</span>, <span>$B$</span> the relation</p><p class="math-container">\[    \mathrm{spost}(A) B = B A\]</p><p>holds. <code>op</code> can be a dense or a sparse operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/superoperators.jl#L134-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.sprepost" href="#QuantumOpticsBase.sprepost"><code>QuantumOpticsBase.sprepost</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sprepost(op)</code></pre><p>Create a super-operator equivalent for left and right side operator multiplication.</p><p>For operators <span>$A$</span>, <span>$B$</span>, <span>$C$</span> the relation</p><p class="math-container">\[    \mathrm{sprepost}(A, B) C = A C B\]</p><p>holds. <code>A</code> ond <code>B</code> can be dense or a sparse operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/superoperators.jl#L154-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.liouvillian" href="#QuantumOpticsBase.liouvillian"><code>QuantumOpticsBase.liouvillian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">liouvillian(H, J; rates, Jdagger)</code></pre><p>Create a super-operator equivalent to the master equation so that <span>$\dot ρ = S ρ$</span>.</p><p>The super-operator <span>$S$</span> is defined by</p><p class="math-container">\[S ρ = -\frac{i}{ħ} [H, ρ] + \sum_i J_i ρ J_i^† - \frac{1}{2} J_i^† J_i ρ - \frac{1}{2} ρ J_i^† J_i\]</p><p><strong>Arguments</strong></p><ul><li><code>H</code>: Hamiltonian.</li><li><code>J</code>: Vector containing the jump operators.</li><li><code>rates</code>: Vector or matrix specifying the coefficients for the jump operators.</li><li><code>Jdagger</code>: Vector containing the hermitian conjugates of the jump operators. If they            are not given they are calculated automatically.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/superoperators.jl#L185-L202">source</a></section></article><ul><li>As far as it makes sense the same functions are implemented for bases, states, operators and superQuantumOpticsBase.</li></ul><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.samebases" href="#QuantumInterface.samebases"><code>QuantumInterface.samebases</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">samebases(a, b)</code></pre><p>Test if two objects have the same bases.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.check_samebases" href="#QuantumInterface.check_samebases"><code>QuantumInterface.check_samebases</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">check_samebases(a, b)</code></pre><p>Throw an <a href="#QuantumInterface.IncompatibleBases"><code>IncompatibleBases</code></a> error if the objects don&#39;t have the same bases.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.@samebases" href="#QuantumInterface.@samebases"><code>QuantumInterface.@samebases</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@samebases</code></pre><p>Macro to skip checks for same bases. Useful for <code>*</code>, <code>expect</code> and similar functions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.multiplicable" href="#QuantumInterface.multiplicable"><code>QuantumInterface.multiplicable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">multiplicable(a, b)</code></pre><p>Check if two objects are multiplicable.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.check_multiplicable" href="#QuantumInterface.check_multiplicable"><code>QuantumInterface.check_multiplicable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">check_multiplicable(a, b)</code></pre><p>Throw an <a href="#QuantumInterface.IncompatibleBases"><code>IncompatibleBases</code></a> error if the objects are not multiplicable.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.basis" href="#QuantumInterface.basis"><code>QuantumInterface.basis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">basis(a)</code></pre><p>Return the basis of an object.</p><p>If it&#39;s ambiguous, e.g. if an operator has a different left and right basis, an <a href="#QuantumInterface.IncompatibleBases"><code>IncompatibleBases</code></a> error is thrown.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.dagger" href="#QuantumInterface.dagger"><code>QuantumInterface.dagger</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dagger(x)</code></pre><p>Hermitian conjugate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/states.jl#L84-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.tensor" href="#QuantumInterface.tensor"><code>QuantumInterface.tensor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tensor(x, y, z...)</code></pre><p>Tensor product of the given objects. Alternatively, the unicode symbol ⊗ (\otimes) can be used.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.projector-Tuple{Ket, Bra}" href="#QuantumInterface.projector-Tuple{Ket, Bra}"><code>QuantumInterface.projector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">projector(a::Ket, b::Bra)</code></pre><p>Projection operator <span>$|a⟩⟨b|$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/operators_dense.jl#L255-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.projector-Tuple{Ket}" href="#QuantumInterface.projector-Tuple{Ket}"><code>QuantumInterface.projector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">projector(a::Ket)</code></pre><p>Projection operator <span>$|a⟩⟨a|$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/operators_dense.jl#L261-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.projector-Tuple{Bra}" href="#QuantumInterface.projector-Tuple{Bra}"><code>QuantumInterface.projector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">projector(a::Bra)</code></pre><p>Projection operator <span>$|a⟩⟨a|$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/operators_dense.jl#L267-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.sparseprojector" href="#QuantumOpticsBase.sparseprojector"><code>QuantumOpticsBase.sparseprojector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sparseprojector([T,] b1, b2)</code></pre><p>Sparse version of <a href="#QuantumInterface.projector-Tuple{Ket, Bra}"><code>projector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/subspace.jl#L106-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.dm" href="#QuantumInterface.dm"><code>QuantumInterface.dm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dm(a::StateVector)</code></pre><p>Create density matrix <span>$|a⟩⟨a|$</span>. Same as <code>projector(a)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/operators_dense.jl#L274-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{StateVector}" href="#LinearAlgebra.norm-Tuple{StateVector}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">norm(x::StateVector)</code></pre><p>Norm of the given bra or ket state.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.tr" href="#LinearAlgebra.tr"><code>LinearAlgebra.tr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tr(x::AbstractOperator)</code></pre><p>Trace of the given operator.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.ptrace" href="#QuantumInterface.ptrace"><code>QuantumInterface.ptrace</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ptrace(a, indices)</code></pre><p>Partial trace of the given basis, state or operator.</p><p>The <code>indices</code> argument, which can be a single integer or a vector of integers, specifies which subsystems are traced out. The number of indices has to be smaller than the number of subsystems, i.e. it is not allowed to perform a full trace.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.normalize-Tuple{StateVector}" href="#LinearAlgebra.normalize-Tuple{StateVector}"><code>LinearAlgebra.normalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalize(x::StateVector)</code></pre><p>Return the normalized state so that <code>norm(x)</code> is one.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.normalize-Tuple{AbstractOperator}" href="#LinearAlgebra.normalize-Tuple{AbstractOperator}"><code>LinearAlgebra.normalize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalize(op)</code></pre><p>Return the normalized operator so that its <code>tr(op)</code> is one.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.normalize!-Tuple{StateVector}" href="#LinearAlgebra.normalize!-Tuple{StateVector}"><code>LinearAlgebra.normalize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalize!(x::StateVector)</code></pre><p>In-place normalization of the given bra or ket so that <code>norm(x)</code> is one.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.normalize!-Tuple{AbstractOperator}" href="#LinearAlgebra.normalize!-Tuple{AbstractOperator}"><code>LinearAlgebra.normalize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalize!(op)</code></pre><p>In-place normalization of the given operator so that its <code>tr(x)</code> is one.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.expect" href="#QuantumInterface.expect"><code>QuantumInterface.expect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expect(index, op, state)</code></pre><p>If an <code>index</code> is given, it assumes that <code>op</code> is defined in the subsystem specified by this number.</p></div></section><section><div><pre><code class="language-none">expect(op, state)</code></pre><p>Expectation value of the given operator <code>op</code> for the specified <code>state</code>.</p><p><code>state</code> can either be a (density) operator or a ket.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/operators.jl#L105-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.variance" href="#QuantumInterface.variance"><code>QuantumInterface.variance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">variance(index, op, state)</code></pre><p>If an <code>index</code> is given, it assumes that <code>op</code> is defined in the subsystem specified by this number</p></div></section><section><div><pre><code class="language-none">variance(op, state)</code></pre><p>Variance of the given operator <code>op</code> for the specified <code>state</code>.</p><p><code>state</code> can either be a (density) operator or a ket.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/operators.jl#L122-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.embed" href="#QuantumInterface.embed"><code>QuantumInterface.embed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">embed(basis1[, basis2], operators::Dict)</code></pre><p><code>operators</code> is a dictionary <code>Dict{Vector{Int}, AbstractOperator}</code>. The integer vector specifies in which subsystems the corresponding operator is defined.</p></div></section><section><div><pre><code class="language-none">embed(basis1[, basis2], indices::Vector, operators::Vector)</code></pre><p>Tensor product of operators where missing indices are filled up with identity operators.</p></div></section><section><div><pre><code class="language-none">embed(basis1[, basis2], indices::Vector, op::AbstractOperator)</code></pre><p>Embed operator acting on a joint Hilbert space where missing indices are filled up with identity operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/operators.jl#L19-L23">source</a></section><section><div><pre><code class="language-none">embed(basis_l::SumBasis, basis_r::SumBasis,
           index::Integer, operator)</code></pre><p>Embed an operator defined on a single subspace specified by the <code>index</code> into a <a href="#QuantumInterface.SumBasis"><code>SumBasis</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/spinors.jl#L86-L92">source</a></section><section><div><pre><code class="language-none">embed(basis_l::SumBasis, basis_r::SumBasis,
            indices, operator)</code></pre><p>Embed an operator defined on multiple subspaces specified by the <code>indices</code> into a <a href="#QuantumInterface.SumBasis"><code>SumBasis</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/spinors.jl#L105-L111">source</a></section><section><div><pre><code class="language-none">embed(basis_l::SumBasis, basis_r::SumBasis,
           indices, operators)</code></pre><p>Embed a list of operators on subspaces specified by the <code>indices</code> into a <a href="#QuantumInterface.SumBasis"><code>SumBasis</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/spinors.jl#L124-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.permutesystems" href="#QuantumInterface.permutesystems"><code>QuantumInterface.permutesystems</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">permutesystems(a, perm)</code></pre><p>Change the ordering of the subsystems of the given object.</p><p>For a permutation vector <code>[2,1,3]</code> and a given object with basis <code>[b1, b2, b3]</code> this function results in <code>[b2, b1, b3]</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Tuple{AbstractOperator}" href="#Base.exp-Tuple{AbstractOperator}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exp(op::AbstractOperator)</code></pre><p>Operator exponential.</p></div></section></article><ul><li>Conversion of operators</li></ul><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.dense" href="#QuantumOpticsBase.dense"><code>QuantumOpticsBase.dense</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dense(op::AbstractOperator)</code></pre><p>Convert an arbitrary Operator into a <a href="#QuantumOpticsBase.DenseOperator"><code>DenseOperator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/operators_dense.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.sparse-Tuple{AbstractOperator}" href="#SparseArrays.sparse-Tuple{AbstractOperator}"><code>SparseArrays.sparse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sparse(op::AbstractOperator)</code></pre><p>Convert an arbitrary operator into a <a href="@ref"><code>SparseOperator</code></a>.</p></div></section></article><ul><li>Time-dependent operators.</li></ul><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.current_time" href="#QuantumOpticsBase.current_time"><code>QuantumOpticsBase.current_time</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">current_time(op::AbstractOperator)</code></pre><p>Returns the current time of the operator <code>op</code>. If <code>op</code> is not time-dependent, this throws an <code>ArgumentError</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/time_dependent_operator.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.set_time!" href="#QuantumOpticsBase.set_time!"><code>QuantumOpticsBase.set_time!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_time!(o::AbstractOperator, t::Number)</code></pre><p>Sets the clock of an operator (see <a href="#QuantumOpticsBase.AbstractTimeDependentOperator"><code>AbstractTimeDependentOperator</code></a>). If <code>o</code> contains other operators (e.g. in case <code>o</code> is a <code>LazyOperator</code>), recursively calls <code>set_time!</code> on those.</p><p>This does nothing in case <code>o</code> is not time-dependent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/time_dependent_operator.jl#L27-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.time_shift" href="#QuantumOpticsBase.time_shift"><code>QuantumOpticsBase.time_shift</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">time_shift(op::TimeDependentSum, t0)</code></pre><p>Shift (translate) a <a href="#QuantumOpticsBase.TimeDependentSum"><code>TimeDependentSum</code></a> <code>op</code> forward in time (delaying its action) by <code>t0</code> units, so that the coefficient functions of time <code>f(t)</code> become <code>f(t-t0)</code>. Return a new <a href="#QuantumOpticsBase.TimeDependentSum"><code>TimeDependentSum</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/time_dependent_operator.jl#L294-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.time_stretch" href="#QuantumOpticsBase.time_stretch"><code>QuantumOpticsBase.time_stretch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">time_stretch(op::TimeDependentSum, Sfactor)</code></pre><p>Stretch (in time) a <a href="#QuantumOpticsBase.TimeDependentSum"><code>TimeDependentSum</code></a> <code>op</code> by a factor of <code>Sfactor</code> (making it &#39;longer&#39;), so that the coefficient functions of time <code>f(t)</code> become <code>f(t/Sfactor)</code>. Return a new <a href="#QuantumOpticsBase.TimeDependentSum"><code>TimeDependentSum</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/time_dependent_operator.jl#L309-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.time_restrict" href="#QuantumOpticsBase.time_restrict"><code>QuantumOpticsBase.time_restrict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">time_restrict(op::TimeDependentSum, t_from, t_to)
time_restrict(op::TimeDependentSum, t_to)</code></pre><p>Restrict a <a href="#QuantumOpticsBase.TimeDependentSum"><code>TimeDependentSum</code></a> <code>op</code> to the time window <code>t_from &lt;= t &lt; t_to</code>, forcing it to be exactly zero outside that range of times. If <code>t_from</code> is not provided, it is assumed to be zero. Return a new <a href="#QuantumOpticsBase.TimeDependentSum"><code>TimeDependentSum</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/time_dependent_operator.jl#L322-L330">source</a></section></article><h3 id="API:-Quantum-objects-exceptions"><a class="docs-heading-anchor" href="#API:-Quantum-objects-exceptions">Exceptions</a><a id="API:-Quantum-objects-exceptions-1"></a><a class="docs-heading-anchor-permalink" href="#API:-Quantum-objects-exceptions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.IncompatibleBases" href="#QuantumInterface.IncompatibleBases"><code>QuantumInterface.IncompatibleBases</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Exception that should be raised for an illegal algebraic operation.</p></div></section></article><h2 id="API:-Quantum-systems"><a class="docs-heading-anchor" href="#API:-Quantum-systems">Quantum systems</a><a id="API:-Quantum-systems-1"></a><a class="docs-heading-anchor-permalink" href="#API:-Quantum-systems" title="Permalink"></a></h2><h3 id="API:-Fock"><a class="docs-heading-anchor" href="#API:-Fock">Fock</a><a id="API:-Fock-1"></a><a class="docs-heading-anchor-permalink" href="#API:-Fock" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.FockBasis" href="#QuantumInterface.FockBasis"><code>QuantumInterface.FockBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FockBasis(N,offset=0)</code></pre><p>Basis for a Fock space where <code>N</code> specifies a cutoff, i.e. what the highest included fock state is. Similarly, the <code>offset</code> defines the lowest included fock state (default is 0). Note that the dimension of this basis is <code>N+1-offset</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.number-Union{Tuple{T}, Tuple{Type{T}, FockBasis}} where T" href="#QuantumOpticsBase.number-Union{Tuple{T}, Tuple{Type{T}, FockBasis}} where T"><code>QuantumOpticsBase.number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">number([T=ComplexF64,] b::FockBasis)</code></pre><p>Number operator for the specified Fock space with optional data type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/fock.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.destroy-Union{Tuple{C}, Tuple{Type{C}, FockBasis}} where C" href="#QuantumOpticsBase.destroy-Union{Tuple{C}, Tuple{Type{C}, FockBasis}} where C"><code>QuantumOpticsBase.destroy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">destroy([T=ComplexF64,] b::FockBasis)</code></pre><p>Annihilation operator for the specified Fock space with optional data type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/fock.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.create-Union{Tuple{C}, Tuple{Type{C}, FockBasis}} where C" href="#QuantumOpticsBase.create-Union{Tuple{C}, Tuple{Type{C}, FockBasis}} where C"><code>QuantumOpticsBase.create</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">create([T=ComplexF64,] b::FockBasis)</code></pre><p>Creation operator for the specified Fock space with optional data type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/fock.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.displace" href="#QuantumOpticsBase.displace"><code>QuantumOpticsBase.displace</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">displace([T=ComplexF64,] b::FockBasis, alpha)</code></pre><p>Displacement operator <span>$D(α)=\exp{\left(α\hat{a}^\dagger-α^*\hat{a}\right)}$</span> for the specified Fock space with optional data type <code>T</code>, computed as the matrix exponential of finite-dimensional (truncated) creation and annihilation operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/fock.jl#L49-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.displace_analytical" href="#QuantumOpticsBase.displace_analytical"><code>QuantumOpticsBase.displace_analytical</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">displace_analytical(alpha::Number, n::Integer, m::Integer)</code></pre><p>Get a specific matrix element of the (analytical) displacement operator in the Fock basis: <code>Dmn = ⟨n|D̂(α)|m⟩</code>. The precision used for computation is based on the type of <code>alpha</code>. If <code>alpha</code> is a Float64, ComplexF64, or Int, the computation will be carried out at double precision.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/fock.jl#L90-L97">source</a></section><section><div><pre><code class="language-none">displace_analytical(b::FockBasis, alpha::Number)
displace_analytical(::Type{T}, b::FockBasis, alpha::Number)</code></pre><p>Get the &quot;analytical&quot; displacement operator, whose matrix elements match (up to numerical imprecision) those of the exact infinite-dimensional displacement operator. This is different to the result of <code>displace(..., alpha)</code>, which computes the matrix exponential <code>exp(alpha * a&#39; - conj(alpha) * a)</code> using finite-dimensional (truncated) creation and annihilation operators <code>a&#39;</code> and <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/fock.jl#L132-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.displace_analytical!" href="#QuantumOpticsBase.displace_analytical!"><code>QuantumOpticsBase.displace_analytical!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">displace_analytical!(op, alpha::Number)</code></pre><p>Overwrite, in place, the matrix elements of the FockBasis operator <code>op</code>, so that it is equal to <code>displace_analytical(eltype(op), basis(op), alpha)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/fock.jl#L117-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.squeeze" href="#QuantumOpticsBase.squeeze"><code>QuantumOpticsBase.squeeze</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">squeeze([T=ComplexF64,] b::SpinBasis, z)</code></pre><p>Squeezing operator <span>$S(z)=\exp{\left(\frac{z^*\hat{J_-}^2 - z\hat{J}_+}{2 N}\right)}$</span> for the  specified Spin-<span>$N/2$</span> basis with optional data type <code>T</code>, computed as the matrix exponential. Too large squeezing (<span>$|z| &gt; \sqrt{N}$</span>) will create an oversqueezed state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/spin.jl#L88-L94">source</a></section><section><div><pre><code class="language-none">squeeze([T=ComplexF64,] b::FockBasis, z)</code></pre><p>Squeezing operator <span>$S(z)=\exp{\left(\frac{z^*\hat{a}^2-z\hat{a}^{\dagger2}}{2}\right)}$</span> for the specified Fock space with optional data type <code>T</code>, computed as the matrix exponential of finite-dimensional (truncated) creation and annihilation operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/fock.jl#L63-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.fockstate" href="#QuantumOpticsBase.fockstate"><code>QuantumOpticsBase.fockstate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fockstate([T=ComplexF64,] b::FockBasis, n)</code></pre><p>Fock state <span>$|n⟩$</span> for the specified Fock space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/fock.jl#L149-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.coherentstate" href="#QuantumOpticsBase.coherentstate"><code>QuantumOpticsBase.coherentstate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coherentstate([T=ComplexF64,] b::FockBasis, alpha)</code></pre><p>Coherent state <span>$|α⟩$</span> for the specified Fock space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/fock.jl#L160-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.coherentstate!" href="#QuantumOpticsBase.coherentstate!"><code>QuantumOpticsBase.coherentstate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coherentstate!(ket::Ket, b::FockBasis, alpha)</code></pre><p>Inplace creation of coherent state <span>$|α⟩$</span> for the specified Fock space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/fock.jl#L172-L176">source</a></section></article><h3 id="API:-N-level"><a class="docs-heading-anchor" href="#API:-N-level">N-level</a><a id="API:-N-level-1"></a><a class="docs-heading-anchor-permalink" href="#API:-N-level" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.NLevelBasis" href="#QuantumInterface.NLevelBasis"><code>QuantumInterface.NLevelBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NLevelBasis(N)</code></pre><p>Basis for a system consisting of N states.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.transition-Union{Tuple{T}, Tuple{Type{T}, NLevelBasis, Integer, Integer}} where T" href="#QuantumOpticsBase.transition-Union{Tuple{T}, Tuple{Type{T}, NLevelBasis, Integer, Integer}} where T"><code>QuantumOpticsBase.transition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transition([T=ComplexF64,] b::NLevelBasis, to::Integer, from::Integer)</code></pre><p>Transition operator <span>$|\mathrm{to}⟩⟨\mathrm{from}|$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/nlevel.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.nlevelstate" href="#QuantumOpticsBase.nlevelstate"><code>QuantumOpticsBase.nlevelstate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nlevelstate([T=ComplexF64,] b::NLevelBasis, n::Integer)</code></pre><p>State where the system is completely in the n-th level.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/nlevel.jl#L22-L26">source</a></section></article><h3 id="API:-Spin"><a class="docs-heading-anchor" href="#API:-Spin">Spin</a><a id="API:-Spin-1"></a><a class="docs-heading-anchor-permalink" href="#API:-Spin" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.SpinBasis" href="#QuantumInterface.SpinBasis"><code>QuantumInterface.SpinBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SpinBasis(n)</code></pre><p>Basis for spin-n particles.</p><p>The basis can be created for arbitrary spinnumbers by using a rational number, e.g. <code>SpinBasis(3//2)</code>. The Pauli operators are defined for all possible spin numbers.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.sigmax" href="#QuantumOpticsBase.sigmax"><code>QuantumOpticsBase.sigmax</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sigmax([T=ComplexF64,] b::SpinBasis)</code></pre><p>Pauli <span>$σ_x$</span> operator for the given Spin basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/spin.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.sigmay" href="#QuantumOpticsBase.sigmay"><code>QuantumOpticsBase.sigmay</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sigmay([T=ComplexF64,] b::SpinBasis)</code></pre><p>Pauli <span>$σ_y$</span> operator for the given Spin basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/spin.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.sigmaz" href="#QuantumOpticsBase.sigmaz"><code>QuantumOpticsBase.sigmaz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sigmaz([T=ComplexF64,] b::SpinBasis)</code></pre><p>Pauli <span>$σ_z$</span> operator for the given Spin basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/spin.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.sigmap" href="#QuantumOpticsBase.sigmap"><code>QuantumOpticsBase.sigmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sigmap([T=ComplexF64,] b::SpinBasis)</code></pre><p>Raising operator <span>$σ_+$</span> for the given Spin basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/spin.jl#L42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.sigmam" href="#QuantumOpticsBase.sigmam"><code>QuantumOpticsBase.sigmam</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sigmam([T=ComplexF64,] b::SpinBasis)</code></pre><p>Lowering operator <span>$σ_-$</span> for the given Spin basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/spin.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.spinup" href="#QuantumOpticsBase.spinup"><code>QuantumOpticsBase.spinup</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">spinup([T=ComplexF64,] b::SpinBasis)</code></pre><p>Spin up state for the given Spin basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/spin.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.spindown" href="#QuantumOpticsBase.spindown"><code>QuantumOpticsBase.spindown</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">spindown([T=ComplexF64], b::SpinBasis)</code></pre><p>Spin down state for the given Spin basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/spin.jl#L79-L83">source</a></section></article><h3 id="API:-Particle"><a class="docs-heading-anchor" href="#API:-Particle">Particle</a><a id="API:-Particle-1"></a><a class="docs-heading-anchor-permalink" href="#API:-Particle" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.PositionBasis" href="#QuantumOpticsBase.PositionBasis"><code>QuantumOpticsBase.PositionBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PositionBasis(xmin, xmax, Npoints)
PositionBasis(b::MomentumBasis)</code></pre><p>Basis for a particle in real space.</p><p>For simplicity periodic boundaries are assumed which means that the rightmost point defined by <code>xmax</code> is not included in the basis but is defined to be the same as <code>xmin</code>.</p><p>When a <a href="#QuantumOpticsBase.MomentumBasis"><code>MomentumBasis</code></a> is given as argument the exact values of <span>$x_{min}$</span> and <span>$x_{max}$</span> are due to the periodic boundary conditions more or less arbitrary and are chosen to be <span>$-\pi/dp$</span> and <span>$\pi/dp$</span> with <span>$dp=(p_{max}-p_{min})/N$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/particle.jl#L6-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.MomentumBasis" href="#QuantumOpticsBase.MomentumBasis"><code>QuantumOpticsBase.MomentumBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MomentumBasis(pmin, pmax, Npoints)
MomentumBasis(b::PositionBasis)</code></pre><p>Basis for a particle in momentum space.</p><p>For simplicity periodic boundaries are assumed which means that <code>pmax</code> is not included in the basis but is defined to be the same as <code>pmin</code>.</p><p>When a <a href="#QuantumOpticsBase.PositionBasis"><code>PositionBasis</code></a> is given as argument the exact values of <span>$p_{min}$</span> and <span>$p_{max}$</span> are due to the periodic boundary conditions more or less arbitrary and are chosen to be <span>$-\pi/dx$</span> and <span>$\pi/dx$</span> with <span>$dx=(x_{max}-x_{min})/N$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/particle.jl#L36-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.spacing" href="#QuantumOpticsBase.spacing"><code>QuantumOpticsBase.spacing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">spacing(b::PositionBasis)</code></pre><p>Difference between two adjacent points of the real space basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/particle.jl#L138-L142">source</a></section><section><div><pre><code class="language-none">spacing(b::MomentumBasis)</code></pre><p>Momentum difference between two adjacent points of the momentum basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/particle.jl#L144-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.samplepoints" href="#QuantumOpticsBase.samplepoints"><code>QuantumOpticsBase.samplepoints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">samplepoints(b::PositionBasis)</code></pre><p>x values of the real space basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/particle.jl#L151-L155">source</a></section><section><div><pre><code class="language-none">samplepoints(b::MomentumBasis)</code></pre><p>p values of the momentum basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/particle.jl#L157-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.position-Union{Tuple{T}, Tuple{Type{T}, PositionBasis}} where T" href="#Base.position-Union{Tuple{T}, Tuple{Type{T}, PositionBasis}} where T"><code>Base.position</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">position([T=ComplexF64,] b::PositionBasis)</code></pre><p>Position operator in real space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/particle.jl#L164-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.position-Union{Tuple{T}, Tuple{Type{T}, MomentumBasis}} where T" href="#Base.position-Union{Tuple{T}, Tuple{Type{T}, MomentumBasis}} where T"><code>Base.position</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">position([T=ComplexF64,] b:MomentumBasis)</code></pre><p>Position operator in momentum space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/particle.jl#L175-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.momentum-Union{Tuple{T}, Tuple{Type{T}, PositionBasis}} where T" href="#QuantumOpticsBase.momentum-Union{Tuple{T}, Tuple{Type{T}, PositionBasis}} where T"><code>QuantumOpticsBase.momentum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">momentum([T=ComplexF64,] b::PositionBasis)</code></pre><p>Momentum operator in real space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/particle.jl#L196-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.momentum-Union{Tuple{T}, Tuple{Type{T}, MomentumBasis}} where T" href="#QuantumOpticsBase.momentum-Union{Tuple{T}, Tuple{Type{T}, MomentumBasis}} where T"><code>QuantumOpticsBase.momentum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">momentum([T=ComplexF64,] b:MomentumBasis)</code></pre><p>Momentum operator in momentum space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/particle.jl#L185-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.potentialoperator" href="#QuantumOpticsBase.potentialoperator"><code>QuantumOpticsBase.potentialoperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">potentialoperator([T=Float64,] b::PositionBasis, V(x))</code></pre><p>Operator representing a potential <span>$V(x)$</span> in real space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/particle.jl#L206-L210">source</a></section><section><div><pre><code class="language-none">potentialoperator([T=ComplexF64,] b::MomentumBasis, V(x))</code></pre><p>Operator representing a potential <span>$V(x)$</span> in momentum space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/particle.jl#L217-L221">source</a></section><section><div><pre><code class="language-none">potentialoperator([T=Float64,] b::CompositeBasis, V(x, y, z, ...))</code></pre><p>Operator representing a potential <span>$V$</span> in more than one dimension.</p><p><strong>Arguments</strong></p><ul><li><code>b</code>: Composite basis consisting purely either of <code>PositionBasis</code> or   <code>MomentumBasis</code>. Note, that calling this with a composite basis in   momentum space might consume a large amount of memory.</li><li><code>V</code>: Function describing the potential. ATTENTION: The number of arguments   accepted by <code>V</code> must match the spatial dimension. Furthermore, the order   of the arguments has to match that of the order of the tensor product of   bases (e.g. if <code>b=bx⊗by⊗bz</code>, then <code>V(x,y,z)</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/particle.jl#L228-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.gaussianstate" href="#QuantumOpticsBase.gaussianstate"><code>QuantumOpticsBase.gaussianstate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gaussianstate([T=ComplexF64,] b::PositionBasis, x0, p0, sigma)
gaussianstate([T=ComplexF64,] b::MomentumBasis, x0, p0, sigma)</code></pre><p>Create a Gaussian state around <code>x0</code> and<code>p0</code> with width <code>sigma</code>.</p><p>In real space the gaussian state is defined as</p><p class="math-container">\[\Psi(x) = \frac{1}{\pi^{1/4}\sqrt{\sigma}}
            e^{i p_0 (x-\frac{x_0}{2}) - \frac{(x-x_0)^2}{2 \sigma^2}}\]</p><p>and is connected to the momentum space definition</p><p class="math-container">\[\Psi(p) = \frac{\sqrt{\sigma}}{\pi^{1/4}}
            e^{-i x_0 (p-\frac{p_0}{2}) - \frac{1}{2}(p-p_0)^2 \sigma^2}\]</p><p>via a Fourier-transformation</p><p class="math-container">\[\Psi(p) = \frac{1}{\sqrt{2\pi}}
            \int_{-\infty}^{\infty} e^{-ipx}\Psi(x) \mathrm{d}x\]</p><p>The state has the properties</p><ul><li><span>$⟨p⟩ = p_0$</span></li><li><span>$⟨x⟩ = x_0$</span></li><li><span>$\mathrm{Var}(x) = \frac{σ^2}{2}$</span></li><li><span>$\mathrm{Var}(p) = \frac{1}{2 σ^2}$</span></li></ul><p>Due to the numerically necessary discretization additional scaling factors <span>$\sqrt{Δx}$</span> and <span>$\sqrt{Δp}$</span> are used so that <span>$\langle x_i|Ψ\rangle = \sqrt{Δ x} Ψ(x_i)$</span> and <span>$\langle p_i|Ψ\rangle = \sqrt{Δ p} Ψ(p_i)$</span> so that the resulting Ket state is normalized.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/particle.jl#L72-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.FFTOperator" href="#QuantumOpticsBase.FFTOperator"><code>QuantumOpticsBase.FFTOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FFTOperator</code></pre><p>Abstract type for all implementations of FFT operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/particle.jl#L278-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.FFTOperators" href="#QuantumOpticsBase.FFTOperators"><code>QuantumOpticsBase.FFTOperators</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FFTOperators</code></pre><p>Operator performing a fast fourier transformation when multiplied with a state that is a Ket or an Operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/particle.jl#L287-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.FFTKets" href="#QuantumOpticsBase.FFTKets"><code>QuantumOpticsBase.FFTKets</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FFTKets</code></pre><p>Operator that can only perform fast fourier transformations on Kets. This is much more memory efficient when only working with Kets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/particle.jl#L313-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.transform" href="#QuantumOpticsBase.transform"><code>QuantumOpticsBase.transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transform(b1::MomentumBasis, b2::PositionBasis)
transform(b1::PositionBasis, b2::MomentumBasis)</code></pre><p>Transformation operator between position basis and momentum basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/particle.jl#L335-L340">source</a></section><section><div><pre><code class="language-none">transform(b1::CompositeBasis, b2::CompositeBasis)</code></pre><p>Transformation operator between two composite bases. Each of the bases has to contain bases of type PositionBasis and the other one a corresponding MomentumBasis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/particle.jl#L359-L365">source</a></section><section><div><pre><code class="language-none">transform([S=ComplexF64, ]b1::PositionBasis, b2::FockBasis; x0=1)
transform([S=ComplexF64, ]b1::FockBasis, b2::PositionBasis; x0=1)</code></pre><p>Transformation operator between position basis and fock basis.</p><p>The coefficients are connected via the relation</p><p class="math-container">\[ψ(x_i) = \sum_{n=0}^N ⟨x_i|n⟩ ψ_n\]</p><p>where <span>$⟨x_i|n⟩$</span> is the value of the n-th eigenstate of a particle in a harmonic trap potential at position <span>$x$</span>, i.e.:</p><p class="math-container">\[⟨x_i|n⟩ = π^{-\frac{1}{4}} \frac{e^{-\frac{1}{2}\left(\frac{x}{x_0}\right)^2}}{\sqrt{x_0}}
            \frac{1}{\sqrt{2^n n!}} H_n\left(\frac{x}{x_0}\right)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/transformations.jl#L3-L19">source</a></section></article><h3 id="API:-Subspace-bases"><a class="docs-heading-anchor" href="#API:-Subspace-bases">Subspace bases</a><a id="API:-Subspace-bases-1"></a><a class="docs-heading-anchor-permalink" href="#API:-Subspace-bases" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.SubspaceBasis" href="#QuantumOpticsBase.SubspaceBasis"><code>QuantumOpticsBase.SubspaceBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SubspaceBasis(basisstates)</code></pre><p>A basis describing a subspace embedded a higher dimensional Hilbert space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/subspace.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.orthonormalize" href="#QuantumOpticsBase.orthonormalize"><code>QuantumOpticsBase.orthonormalize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">orthonormalize(b::SubspaceBasis)</code></pre><p>Orthonormalize the basis states of the given <a href="#QuantumOpticsBase.SubspaceBasis"><code>SubspaceBasis</code></a></p><p>A modified Gram-Schmidt process is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/subspace.jl#L32-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.projector-Union{Tuple{T}, Tuple{Type{T}, SubspaceBasis, SubspaceBasis}} where T" href="#QuantumInterface.projector-Union{Tuple{T}, Tuple{Type{T}, SubspaceBasis, SubspaceBasis}} where T"><code>QuantumInterface.projector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">projector([T,] b1, b2)</code></pre><p>Projection operator between subspaces and superspaces or between two subspaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/subspace.jl#L54-L58">source</a></section></article><h3 id="API:-Many-body"><a class="docs-heading-anchor" href="#API:-Many-body">Many-body</a><a id="API:-Many-body-1"></a><a class="docs-heading-anchor-permalink" href="#API:-Many-body" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.ManyBodyBasis" href="#QuantumOpticsBase.ManyBodyBasis"><code>QuantumOpticsBase.ManyBodyBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ManyBodyBasis(b, occupations)</code></pre><p>Basis for a many body system.</p><p>The basis has to know the associated one-body basis <code>b</code> and which occupation states should be included. The occupations_hash is used to speed up checking if two many-body bases are equal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/manybody.jl#L30-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.fermionstates" href="#QuantumOpticsBase.fermionstates"><code>QuantumOpticsBase.fermionstates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fermionstates(Nmodes, Nparticles)
fermionstates(b, Nparticles)</code></pre><p>Generate all fermionic occupation states for N-particles in M-modes. <code>Nparticles</code> can be a vector to define a Hilbert space with variable particle number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/manybody.jl#L52-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.bosonstates" href="#QuantumOpticsBase.bosonstates"><code>QuantumOpticsBase.bosonstates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bosonstates(Nmodes, Nparticles)
bosonstates(b, Nparticles)</code></pre><p>Generate all bosonic occupation states for N-particles in M-modes. <code>Nparticles</code> can be a vector to define a Hilbert space with variable particle number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/manybody.jl#L64-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.number-Union{Tuple{T}, Tuple{Type{T}, ManyBodyBasis, Any}} where T" href="#QuantumOpticsBase.number-Union{Tuple{T}, Tuple{Type{T}, ManyBodyBasis, Any}} where T"><code>QuantumOpticsBase.number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">number([T=ComplexF64,] b::ManyBodyBasis, index)</code></pre><p>Particle number operator for the i-th mode of the many-body basis <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/manybody.jl#L146-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.number-Union{Tuple{T}, Tuple{Type{T}, ManyBodyBasis}} where T" href="#QuantumOpticsBase.number-Union{Tuple{T}, Tuple{Type{T}, ManyBodyBasis}} where T"><code>QuantumOpticsBase.number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">number([T=ComplexF64,] b::ManyBodyBasis)</code></pre><p>Total particle number operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/manybody.jl#L156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.destroy-Union{Tuple{T}, Tuple{Type{T}, ManyBodyBasis, Any}} where T" href="#QuantumOpticsBase.destroy-Union{Tuple{T}, Tuple{Type{T}, ManyBodyBasis, Any}} where T"><code>QuantumOpticsBase.destroy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">destroy([T=ComplexF64,] b::ManyBodyBasis, index)</code></pre><p>Annihilation operator for the i-th mode of the many-body basis <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/manybody.jl#L119-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.create-Union{Tuple{T}, Tuple{Type{T}, ManyBodyBasis, Any}} where T" href="#QuantumOpticsBase.create-Union{Tuple{T}, Tuple{Type{T}, ManyBodyBasis, Any}} where T"><code>QuantumOpticsBase.create</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">create([T=ComplexF64,] b::ManyBodyBasis, index)</code></pre><p>Creation operator for the i-th mode of the many-body basis <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/manybody.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.transition-Union{Tuple{T}, Tuple{Type{T}, ManyBodyBasis, Any, Any}} where T" href="#QuantumOpticsBase.transition-Union{Tuple{T}, Tuple{Type{T}, ManyBodyBasis, Any, Any}} where T"><code>QuantumOpticsBase.transition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transition([T=ComplexF64,] b::ManyBodyBasis, to, from)</code></pre><p>Operator <span>$|\mathrm{to}⟩⟨\mathrm{from}|$</span> transferring particles between modes.</p><p>Note that <code>to</code> and <code>from</code> can be collections of indices. The resulting operator in this case will be equal to <span>$a^\dagger_{to_1} a^\dagger_{to_2} \ldots a_{from_2} a_{from_1}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/manybody.jl#L166-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.manybodyoperator" href="#QuantumOpticsBase.manybodyoperator"><code>QuantumOpticsBase.manybodyoperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">manybodyoperator(b::ManyBodyBasis, op)</code></pre><p>Create the many-body operator from the given one-body operator <code>op</code>.</p><p>The given operator can either be a one-body operator or a two-body interaction. Higher order interactions are at the moment not implemented.</p><p>The mathematical formalism for the one-body case is described by</p><p class="math-container">\[X = \sum_{ij} a_i^† a_j ⟨u_i| x | u_j⟩\]</p><p>and for the interaction case by</p><p class="math-container">\[X = \sum_{ijkl} a_i^† a_j^† a_k a_l ⟨u_i|⟨u_j| x |u_k⟩|u_l⟩\]</p><p>where <span>$X$</span> is the N-particle operator, <span>$x$</span> is the one-body operator and <span>$|u⟩$</span> are the one-body states associated to the different modes of the N-particle basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/manybody.jl#L194-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.onebodyexpect" href="#QuantumOpticsBase.onebodyexpect"><code>QuantumOpticsBase.onebodyexpect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">onebodyexpect(op, state)</code></pre><p>Expectation value of the one-body operator <code>op</code> in respect to the many-body <code>state</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/manybody.jl#L314-L318">source</a></section></article><h2 id="API:-Direct-sum"><a class="docs-heading-anchor" href="#API:-Direct-sum">Direct sum</a><a id="API:-Direct-sum-1"></a><a class="docs-heading-anchor-permalink" href="#API:-Direct-sum" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.SumBasis" href="#QuantumInterface.SumBasis"><code>QuantumInterface.SumBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SumBasis(b1, b2...)</code></pre><p>Similar to <a href="#QuantumInterface.CompositeBasis"><code>CompositeBasis</code></a> but for the <a href="#QuantumInterface.directsum"><code>directsum</code></a> (⊕)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.directsum" href="#QuantumInterface.directsum"><code>QuantumInterface.directsum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">directsum(b1::Basis, b2::Basis)</code></pre><p>Construct the <a href="#QuantumInterface.SumBasis"><code>SumBasis</code></a> out of two sub-bases.</p></div></section><section><div><pre><code class="language-none">directsum(x::Ket, y::Ket)</code></pre><p>Construct a spinor via the <a href="#QuantumInterface.directsum"><code>directsum</code></a> of two <a href="#QuantumOpticsBase.Ket"><code>Ket</code></a>s. The result is a <a href="#QuantumOpticsBase.Ket"><code>Ket</code></a> with data given by <code>[x.data;y.data]</code> and its basis given by the corresponding <a href="#QuantumInterface.SumBasis"><code>SumBasis</code></a>. <strong>NOTE</strong>: The resulting state is not normalized!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/spinors.jl#L3-L10">source</a></section><section><div><pre><code class="language-none">directsum(x::DataOperator, y::DataOperator)</code></pre><p>Compute the direct sum of two operators. The result is an operator on the corresponding <a href="#QuantumInterface.SumBasis"><code>SumBasis</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/spinors.jl#L37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.LazyDirectSum" href="#QuantumOpticsBase.LazyDirectSum"><code>QuantumOpticsBase.LazyDirectSum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LazyDirectSum &lt;: AbstractOperator</code></pre><p>Lazy implementation of <code>directsum</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/spinors.jl#L153-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.getblock" href="#QuantumOpticsBase.getblock"><code>QuantumOpticsBase.getblock</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getblock(x::Ket{&lt;:SumBasis}, i)</code></pre><p>For a <a href="#QuantumOpticsBase.Ket"><code>Ket</code></a> defined on a <a href="#QuantumInterface.SumBasis"><code>SumBasis</code></a>, get the state as it is defined on the ith sub-basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/spinors.jl#L13-L18">source</a></section><section><div><pre><code class="language-none">getblock(op::Operator{&lt;:SumBasis,&lt;:SumBasis}, i, j)</code></pre><p>Get the sub-basis operator corresponding to the block <code>(i,j)</code> of <code>op</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/spinors.jl#L73-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.setblock!" href="#QuantumOpticsBase.setblock!"><code>QuantumOpticsBase.setblock!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setblock!(x::Ket{&lt;:SumBasis}, val::Ket, i)</code></pre><p>Set the data of <code>x</code> on the ith sub-basis equal to the data of <code>val</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/spinors.jl#L25-L29">source</a></section><section><div><pre><code class="language-none">setblock!(op::DataOperator{&lt;:SumBasis,&lt;:SumBasis}, val::DataOperator, i, j)</code></pre><p>Set the data of <code>op</code> corresponding to the block <code>(i,j)</code> equal to the data of <code>val</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/spinors.jl#L58-L62">source</a></section></article><h2 id="API:-Metrics"><a class="docs-heading-anchor" href="#API:-Metrics">Metrics</a><a id="API:-Metrics-1"></a><a class="docs-heading-anchor-permalink" href="#API:-Metrics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.tracenorm" href="#QuantumOpticsBase.tracenorm"><code>QuantumOpticsBase.tracenorm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tracenorm(rho)</code></pre><p>Trace norm of <code>rho</code>.</p><p>It is defined as</p><p class="math-container">\[T(ρ) = Tr\{\sqrt{ρ^† ρ}\}.\]</p><p>Depending if <code>rho</code> is hermitian either <a href="#QuantumOpticsBase.tracenorm_h"><code>tracenorm_h</code></a> or <a href="#QuantumOpticsBase.tracenorm_nh"><code>tracenorm_nh</code></a> is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/metrics.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.tracenorm_h" href="#QuantumOpticsBase.tracenorm_h"><code>QuantumOpticsBase.tracenorm_h</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tracenorm_h(rho)</code></pre><p>Trace norm of <code>rho</code>.</p><p>It uses the identity</p><p class="math-container">\[T(ρ) = Tr\{\sqrt{ρ^† ρ}\} = \sum_i |λ_i|\]</p><p>where <span>$λ_i$</span> are the eigenvalues of <code>rho</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/metrics.jl#L22-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.tracenorm_nh" href="#QuantumOpticsBase.tracenorm_nh"><code>QuantumOpticsBase.tracenorm_nh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tracenorm_nh(rho)</code></pre><p>Trace norm of <code>rho</code>.</p><p>Note that in this case <code>rho</code> doesn&#39;t have to be represented by a square matrix (i.e. it can have different left-hand and right-hand bases).</p><p>It uses the identity</p><p class="math-container">\[    T(ρ) = Tr\{\sqrt{ρ^† ρ}\} = \sum_i σ_i\]</p><p>where <span>$σ_i$</span> are the singular values of <code>rho</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/metrics.jl#L44-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.tracedistance" href="#QuantumOpticsBase.tracedistance"><code>QuantumOpticsBase.tracedistance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tracedistance(rho, sigma)</code></pre><p>Trace distance between <code>rho</code> and <code>sigma</code>.</p><p>It is defined as</p><p class="math-container">\[T(ρ,σ) = \frac{1}{2} Tr\{\sqrt{(ρ - σ)^† (ρ - σ)}\}.\]</p><p>It calls <a href="#QuantumOpticsBase.tracenorm"><code>tracenorm</code></a> which in turn either uses <a href="#QuantumOpticsBase.tracenorm_h"><code>tracenorm_h</code></a> or <a href="#QuantumOpticsBase.tracenorm_nh"><code>tracenorm_nh</code></a> depending if <span>$ρ-σ$</span> is hermitian or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/metrics.jl#L66-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.tracedistance_h" href="#QuantumOpticsBase.tracedistance_h"><code>QuantumOpticsBase.tracedistance_h</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tracedistance_h(rho, sigma)</code></pre><p>Trace distance between <code>rho</code> and <code>sigma</code>.</p><p>It uses the identity</p><p class="math-container">\[T(ρ,σ) = \frac{1}{2} Tr\{\sqrt{(ρ - σ)^† (ρ - σ)}\} = \frac{1}{2} \sum_i |λ_i|\]</p><p>where <span>$λ_i$</span> are the eigenvalues of <code>rho</code> - <code>sigma</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/metrics.jl#L85-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.tracedistance_nh" href="#QuantumOpticsBase.tracedistance_nh"><code>QuantumOpticsBase.tracedistance_nh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tracedistance_nh(rho, sigma)</code></pre><p>Trace distance between <code>rho</code> and <code>sigma</code>.</p><p>Note that in this case <code>rho</code> and <code>sigma</code> don&#39;t have to be represented by square matrices (i.e. they can have different left-hand and right-hand bases).</p><p>It uses the identity</p><p class="math-container">\[    T(ρ,σ) = \frac{1}{2} Tr\{\sqrt{(ρ - σ)^† (ρ - σ)}\}
         = \frac{1}{2} \sum_i σ_i\]</p><p>where <span>$σ_i$</span> are the singular values of <code>rho</code> - <code>sigma</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/metrics.jl#L103-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.entropy_vn" href="#QuantumOpticsBase.entropy_vn"><code>QuantumOpticsBase.entropy_vn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">entropy_vn(rho)</code></pre><p>Von Neumann entropy of a density matrix.</p><p>The Von Neumann entropy of a density operator is defined as</p><p class="math-container">\[S(ρ) = -Tr(ρ \log(ρ)) = -\sum_n λ_n\log(λ_n)\]</p><p>where <span>$λ_n$</span> are the eigenvalues of the density matrix <span>$ρ$</span>, <span>$\log$</span> is the natural logarithm and <span>$0\log(0) ≡ 0$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>rho</code>: Density operator of which to calculate Von Neumann entropy.</li><li><code>tol=1e-15</code>: Tolerance for rounding errors in the computed eigenvalues.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/metrics.jl#L126-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.entropy_renyi" href="#QuantumOpticsBase.entropy_renyi"><code>QuantumOpticsBase.entropy_renyi</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">entropy_renyi(rho, α::Integer=2)</code></pre><p>Renyi α-entropy of a density matrix, where r α≥0, α≂̸1.</p><p>The Renyi α-entropy of a density operator is defined as</p><p class="math-container">\[S_α(ρ) = 1/(1-α) \log(Tr(ρ^α))\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/metrics.jl#L156-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.fidelity" href="#QuantumOpticsBase.fidelity"><code>QuantumOpticsBase.fidelity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fidelity(rho, sigma)</code></pre><p>Fidelity of two density operators.</p><p>The fidelity of two density operators <span>$ρ$</span> and <span>$σ$</span> is defined by</p><p class="math-container">\[F(ρ, σ) = Tr\left(\sqrt{\sqrt{ρ}σ\sqrt{ρ}}\right),\]</p><p>where <span>$\sqrt{ρ}=\sum_n\sqrt{λ_n}|ψ⟩⟨ψ|$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/metrics.jl#L176-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.ptranspose" href="#QuantumOpticsBase.ptranspose"><code>QuantumOpticsBase.ptranspose</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ptranspose(rho, indices)</code></pre><p>Partial transpose of rho with respect to subsystem specified by indices. </p><p>The <code>indices</code> argument can be a single integer or a collection of integers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/metrics.jl#L192-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.PPT" href="#QuantumOpticsBase.PPT"><code>QuantumOpticsBase.PPT</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">PPT(rho, index)</code></pre><p>Peres-Horodecki criterion of partial transpose.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/metrics.jl#L216-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.negativity" href="#QuantumOpticsBase.negativity"><code>QuantumOpticsBase.negativity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">negativity(rho, index)</code></pre><p>Negativity of rho with respect to subsystem index.</p><p>The negativity of a density matrix ρ is defined as</p><p class="math-container">\[N(ρ) = \frac{\|ρᵀ\|-1}{2},\]</p><p>where <code>ρᵀ</code> is the partial transpose.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/metrics.jl#L224-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.logarithmic_negativity" href="#QuantumOpticsBase.logarithmic_negativity"><code>QuantumOpticsBase.logarithmic_negativity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">logarithmic_negativity(rho, index)</code></pre><p>The logarithmic negativity of a density matrix ρ is defined as</p><p class="math-container">\[N(ρ) = \log₂\|ρᵀ\|,\]</p><p>where <code>ρᵀ</code> is the partial transpose.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/metrics.jl#L239-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.entanglement_entropy" href="#QuantumOpticsBase.entanglement_entropy"><code>QuantumOpticsBase.entanglement_entropy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">entanglement_entropy(state, partition, [entropy_fun=entropy_vn])</code></pre><p>Computes the entanglement entropy of <code>state</code> between the list of sites <code>partition</code> and the rest of the system. The state must be defined in a composite basis.</p><p>If <code>state isa AbstractOperator</code> the operator-space entanglement entropy is computed, which has the property</p><pre><code class="language-julia">entanglement_entropy(dm(ket)) = 2 * entanglement_entropy(ket)</code></pre><p>By default the computed entropy is the Von-Neumann entropy, but a different function can be provided (for example to compute the entanglement-renyi entropy).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/metrics.jl#L262-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.avg_gate_fidelity" href="#QuantumOpticsBase.avg_gate_fidelity"><code>QuantumOpticsBase.avg_gate_fidelity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">avg_gate_fidelity(x, y)</code></pre><p>The average gate fidelity between two superoperators x and y.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/metrics.jl#L252-L256">source</a></section></article><h2 id="API:-State-definitions"><a class="docs-heading-anchor" href="#API:-State-definitions">State definitions</a><a id="API:-State-definitions-1"></a><a class="docs-heading-anchor-permalink" href="#API:-State-definitions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.randstate" href="#QuantumOpticsBase.randstate"><code>QuantumOpticsBase.randstate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randstate([T=ComplexF64,] basis)</code></pre><p>Calculate a random normalized ket state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/state_definitions.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.thermalstate" href="#QuantumOpticsBase.thermalstate"><code>QuantumOpticsBase.thermalstate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">thermalstate(H,T)</code></pre><p>Thermal state <span>$exp(-H/T)/Tr[exp(-H/T)]$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/state_definitions.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.coherentthermalstate" href="#QuantumOpticsBase.coherentthermalstate"><code>QuantumOpticsBase.coherentthermalstate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coherentthermalstate([C=ComplexF64,] basis::FockBasis,H,T,alpha)</code></pre><p>Coherent thermal state <span>$D(α)exp(-H/T)/Tr[exp(-H/T)]D^†(α)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/state_definitions.jl#L47-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.phase_average" href="#QuantumOpticsBase.phase_average"><code>QuantumOpticsBase.phase_average</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">phase_average(rho)</code></pre><p>Returns the phase-average of <span>$ρ$</span> containing only the diagonal elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/state_definitions.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.passive_state" href="#QuantumOpticsBase.passive_state"><code>QuantumOpticsBase.passive_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">passive_state(rho,IncreasingEigenenergies=true)</code></pre><p>Passive state <span>$π$</span> of <span>$ρ$</span>. IncreasingEigenenergies=true means that higher indices correspond to higher energies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/state_definitions.jl#L67-L71">source</a></section></article><h2 id="API:-Pauli"><a class="docs-heading-anchor" href="#API:-Pauli">Pauli</a><a id="API:-Pauli-1"></a><a class="docs-heading-anchor-permalink" href="#API:-Pauli" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuantumInterface.PauliBasis" href="#QuantumInterface.PauliBasis"><code>QuantumInterface.PauliBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PauliBasis(num_qubits::Int)</code></pre><p>Basis for an N-qubit space where <code>num_qubits</code> specifies the number of qubits. The dimension of the basis is 2²ᴺ.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.PauliTransferMatrix" href="#QuantumOpticsBase.PauliTransferMatrix"><code>QuantumOpticsBase.PauliTransferMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Base class for Pauli transfer matrix classes.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/pauli.jl#L4-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.DensePauliTransferMatrix" href="#QuantumOpticsBase.DensePauliTransferMatrix"><code>QuantumOpticsBase.DensePauliTransferMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DensePauliTransferMatrix(B1, B2, data)</code></pre><p>DensePauliTransferMatrix stored as a dense matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/pauli.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.ChiMatrix" href="#QuantumOpticsBase.ChiMatrix"><code>QuantumOpticsBase.ChiMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Base class for χ (process) matrix classes.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/pauli.jl#L36-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.DenseChiMatrix" href="#QuantumOpticsBase.DenseChiMatrix"><code>QuantumOpticsBase.DenseChiMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DenseChiMatrix(b, b, data)</code></pre><p>DenseChiMatrix stored as a dense matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/pauli.jl#L41-L45">source</a></section></article><h2 id="API:-Printing"><a class="docs-heading-anchor" href="#API:-Printing">Printing</a><a id="API:-Printing-1"></a><a class="docs-heading-anchor-permalink" href="#API:-Printing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.set_printing" href="#QuantumOpticsBase.set_printing"><code>QuantumOpticsBase.set_printing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">QuantumOptics.set_printing(; standard_order, rounding_tol)</code></pre><p>Set options for REPL output.</p><p><strong>Arguments</strong></p><ul><li><code>standard_order=false</code>: For performance reasons, the order of the tensor   product is inverted, i.e. <code>tensor(a, b)=kron(b, a)</code>. When changing this   to <code>true</code>, the output shown in the REPL will exhibit the correct order.</li><li><code>rounding_tol=1e-17</code>: Tolerance for floating point errors shown in the output.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/printing.jl#L3-L13">source</a></section></article><h2 id="API:-LazyTensor-functions"><a class="docs-heading-anchor" href="#API:-LazyTensor-functions">LazyTensor functions</a><a id="API:-LazyTensor-functions-1"></a><a class="docs-heading-anchor-permalink" href="#API:-LazyTensor-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.lazytensor_enable_cache" href="#QuantumOpticsBase.lazytensor_enable_cache"><code>QuantumOpticsBase.lazytensor_enable_cache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lazytensor_enable_cache(; maxsize::Int = ..., maxrelsize::Real = ...)</code></pre><p>(Re)-enable the cache for further use; set the maximal size <code>maxsize</code> (as number of bytes) or relative size <code>maxrelsize</code>, as a fraction between 0 and 1, resulting in <code>maxsize = floor(Int, maxrelsize * Sys.total_memory())</code>. Default value is <code>maxsize = 2^32</code> bytes, which amounts to 4 gigabytes of memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/operators_lazytensor.jl#L261-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.lazytensor_disable_cache" href="#QuantumOpticsBase.lazytensor_disable_cache"><code>QuantumOpticsBase.lazytensor_disable_cache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lazytensor_disable_cache()</code></pre><p>Disable the cache for further use but does not clear its current contents. Also see <a href="#QuantumOpticsBase.lazytensor_clear_cache"><code>lazytensor_clear_cache()</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/operators_lazytensor.jl#L251-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.lazytensor_cachesize" href="#QuantumOpticsBase.lazytensor_cachesize"><code>QuantumOpticsBase.lazytensor_cachesize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lazytensor_cachesize()</code></pre><p>Return the current memory size (in bytes) of all the objects in the cache.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/operators_lazytensor.jl#L245-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumOpticsBase.lazytensor_clear_cache" href="#QuantumOpticsBase.lazytensor_clear_cache"><code>QuantumOpticsBase.lazytensor_clear_cache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lazytensor_clear_cache()</code></pre><p>Clear the current contents of the cache.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qojulia/QuantumOpticsBase.jl/blob/da3971a43c55e4b957f61b69e3e6981b75c7a1b5/src/operators_lazytensor.jl#L236-L239">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 26 January 2024 16:24">Friday 26 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
